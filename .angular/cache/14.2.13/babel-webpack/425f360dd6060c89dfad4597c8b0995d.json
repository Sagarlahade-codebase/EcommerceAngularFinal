{"ast":null,"code":"import _asyncToGenerator from \"/Users/tushar/Desktop/fullstack-angular-and-springboot-master/source-code/ecommerce-project-release-3.0/09-security-order-history-secure-backend-and-frontend/03-frontend/angular-ecommerce/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { removeNils, clone } from './util/object.js';\nimport AuthSdkError from './errors/AuthSdkError.js';\nimport { isLocalhost, isIE11OrLess } from './features.js';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from './constants.js';\nimport { validateToken } from './oidc/util/validateToken.js';\nimport SdkClock from './clock.js';\nimport './idx/types/api.js';\nimport { isRefreshToken, isAccessToken, isIDToken } from './types/Token.js';\nimport { EVENT_EXPIRED, EVENT_RENEWED, EVENT_ADDED, EVENT_REMOVED, EVENT_ERROR, EVENT_SET_STORAGE } from './types/TokenManager.js';\nimport './myaccount/types.js';\nconst DEFAULT_OPTIONS = {\n  autoRenew: true,\n  autoRemove: true,\n  syncStorage: true,\n  clearPendingRemoveTokens: true,\n  storage: undefined,\n  expireEarlySeconds: 30,\n  storageKey: TOKEN_STORAGE_NAME\n};\nfunction defaultState() {\n  return {\n    expireTimeouts: {},\n    renewPromise: null\n  };\n}\nclass TokenManager {\n  constructor(sdk, options = {}) {\n    this.sdk = sdk;\n    this.emitter = sdk.emitter;\n    if (!this.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before TokenManager');\n    }\n    options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n    if (!isLocalhost()) {\n      options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n    }\n    this.options = options;\n    const storageOptions = removeNils({\n      storageKey: options.storageKey,\n      secure: options.secure\n    });\n    if (typeof options.storage === 'object') {\n      storageOptions.storageProvider = options.storage;\n    } else if (options.storage) {\n      storageOptions.storageType = options.storage;\n    }\n    this.storage = sdk.storageManager.getTokenStorage(Object.assign(Object.assign({}, storageOptions), {\n      useSeparateCookies: true\n    }));\n    this.clock = SdkClock.create();\n    this.state = defaultState();\n  }\n  on(event, handler, context) {\n    if (context) {\n      this.emitter.on(event, handler, context);\n    } else {\n      this.emitter.on(event, handler);\n    }\n  }\n  off(event, handler) {\n    if (handler) {\n      this.emitter.off(event, handler);\n    } else {\n      this.emitter.off(event);\n    }\n  }\n  hasSharedStorage() {\n    return this.storage.isSharedStorage();\n  }\n  start() {\n    if (this.options.clearPendingRemoveTokens) {\n      this.clearPendingRemoveTokens();\n    }\n    this.setExpireEventTimeoutAll();\n  }\n  stop() {\n    this.clearExpireEventTimeoutAll();\n  }\n  getOptions() {\n    return clone(this.options);\n  }\n  getExpireTime(token) {\n    const expireEarlySeconds = this.options.expireEarlySeconds || 0;\n    var expireTime = token.expiresAt - expireEarlySeconds;\n    return expireTime;\n  }\n  hasExpired(token) {\n    var expireTime = this.getExpireTime(token);\n    return expireTime <= this.clock.now();\n  }\n  emitExpired(key, token) {\n    this.emitter.emit(EVENT_EXPIRED, key, token);\n  }\n  emitRenewed(key, freshToken, oldToken) {\n    this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n  }\n  emitAdded(key, token) {\n    this.emitter.emit(EVENT_ADDED, key, token);\n  }\n  emitRemoved(key, token) {\n    this.emitter.emit(EVENT_REMOVED, key, token);\n  }\n  emitError(error) {\n    this.emitter.emit(EVENT_ERROR, error);\n  }\n  clearExpireEventTimeout(key) {\n    clearTimeout(this.state.expireTimeouts[key]);\n    delete this.state.expireTimeouts[key];\n    this.state.renewPromise = null;\n  }\n  clearExpireEventTimeoutAll() {\n    var expireTimeouts = this.state.expireTimeouts;\n    for (var key in expireTimeouts) {\n      if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n        continue;\n      }\n      this.clearExpireEventTimeout(key);\n    }\n  }\n  setExpireEventTimeout(key, token) {\n    if (isRefreshToken(token)) {\n      return;\n    }\n    var expireTime = this.getExpireTime(token);\n    var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n    this.clearExpireEventTimeout(key);\n    var expireEventTimeout = setTimeout(() => {\n      this.emitExpired(key, token);\n    }, expireEventWait);\n    this.state.expireTimeouts[key] = expireEventTimeout;\n  }\n  setExpireEventTimeoutAll() {\n    var tokenStorage = this.storage.getStorage();\n    for (var key in tokenStorage) {\n      if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n        continue;\n      }\n      var token = tokenStorage[key];\n      this.setExpireEventTimeout(key, token);\n    }\n  }\n  resetExpireEventTimeoutAll() {\n    this.clearExpireEventTimeoutAll();\n    this.setExpireEventTimeoutAll();\n  }\n  add(key, token) {\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    this.emitAdded(key, token);\n    this.setExpireEventTimeout(key, token);\n  }\n  getSync(key) {\n    var tokenStorage = this.storage.getStorage();\n    return tokenStorage[key];\n  }\n  get(key) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.getSync(key);\n    })();\n  }\n  getTokensSync() {\n    const tokens = {};\n    const tokenStorage = this.storage.getStorage();\n    Object.keys(tokenStorage).forEach(key => {\n      const token = tokenStorage[key];\n      if (isAccessToken(token)) {\n        tokens.accessToken = token;\n      } else if (isIDToken(token)) {\n        tokens.idToken = token;\n      } else if (isRefreshToken(token)) {\n        tokens.refreshToken = token;\n      }\n    });\n    return tokens;\n  }\n  getTokens() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.getTokensSync();\n    })();\n  }\n  getStorageKeyByType(type) {\n    const tokenStorage = this.storage.getStorage();\n    const key = Object.keys(tokenStorage).filter(key => {\n      const token = tokenStorage[key];\n      return isAccessToken(token) && type === 'accessToken' || isIDToken(token) && type === 'idToken' || isRefreshToken(token) && type === 'refreshToken';\n    })[0];\n    return key;\n  }\n  getTokenType(token) {\n    if (isAccessToken(token)) {\n      return 'accessToken';\n    }\n    if (isIDToken(token)) {\n      return 'idToken';\n    }\n    if (isRefreshToken(token)) {\n      return 'refreshToken';\n    }\n    throw new AuthSdkError('Unknown token type');\n  }\n  emitSetStorageEvent() {\n    if (isIE11OrLess()) {\n      const storage = this.storage.getStorage();\n      this.emitter.emit(EVENT_SET_STORAGE, storage);\n    }\n  }\n  getStorage() {\n    return this.storage;\n  }\n  setTokens(tokens, accessTokenCb, idTokenCb, refreshTokenCb) {\n    const handleTokenCallback = (key, token) => {\n      const type = this.getTokenType(token);\n      if (type === 'accessToken') {\n        accessTokenCb && accessTokenCb(key, token);\n      } else if (type === 'idToken') {\n        idTokenCb && idTokenCb(key, token);\n      } else if (type === 'refreshToken') {\n        refreshTokenCb && refreshTokenCb(key, token);\n      }\n    };\n    const handleAdded = (key, token) => {\n      this.emitAdded(key, token);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n    const handleRenewed = (key, token, oldToken) => {\n      this.emitRenewed(key, token, oldToken);\n      this.clearExpireEventTimeout(key);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n    const handleRemoved = (key, token) => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, token);\n      handleTokenCallback(key, token);\n    };\n    const types = ['idToken', 'accessToken', 'refreshToken'];\n    const existingTokens = this.getTokensSync();\n    types.forEach(type => {\n      const token = tokens[type];\n      if (token) {\n        validateToken(token, type);\n      }\n    });\n    const storage = types.reduce((storage, type) => {\n      const token = tokens[type];\n      if (token) {\n        const storageKey = this.getStorageKeyByType(type) || type;\n        storage[storageKey] = token;\n      }\n      return storage;\n    }, {});\n    this.storage.setStorage(storage);\n    this.emitSetStorageEvent();\n    types.forEach(type => {\n      const newToken = tokens[type];\n      const existingToken = existingTokens[type];\n      const storageKey = this.getStorageKeyByType(type) || type;\n      if (newToken && existingToken) {\n        handleRemoved(storageKey, existingToken);\n        handleAdded(storageKey, newToken);\n        handleRenewed(storageKey, newToken, existingToken);\n      } else if (newToken) {\n        handleAdded(storageKey, newToken);\n      } else if (existingToken) {\n        handleRemoved(storageKey, existingToken);\n      }\n    });\n  }\n  remove(key) {\n    this.clearExpireEventTimeout(key);\n    var tokenStorage = this.storage.getStorage();\n    var removedToken = tokenStorage[key];\n    delete tokenStorage[key];\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    this.emitRemoved(key, removedToken);\n  }\n  renewToken(token) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      return (_a = _this3.sdk.token) === null || _a === void 0 ? void 0 : _a.renew(token);\n    })();\n  }\n  validateToken(token) {\n    return validateToken(token);\n  }\n  renew(key) {\n    if (this.state.renewPromise) {\n      return this.state.renewPromise;\n    }\n    try {\n      var token = this.getSync(key);\n      if (!token) {\n        throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n    this.clearExpireEventTimeout(key);\n    this.state.renewPromise = this.sdk.token.renewTokens().then(tokens => {\n      this.setTokens(tokens);\n      const tokenType = this.getTokenType(token);\n      return tokens[tokenType];\n    }).catch(err => {\n      this.remove(key);\n      err.tokenKey = key;\n      this.emitError(err);\n      throw err;\n    }).finally(() => {\n      this.state.renewPromise = null;\n    });\n    return this.state.renewPromise;\n  }\n  clear() {\n    const tokens = this.getTokensSync();\n    this.clearExpireEventTimeoutAll();\n    this.storage.clearStorage();\n    this.emitSetStorageEvent();\n    Object.keys(tokens).forEach(key => {\n      this.emitRemoved(key, tokens[key]);\n    });\n  }\n  clearPendingRemoveTokens() {\n    const tokenStorage = this.storage.getStorage();\n    const removedTokens = {};\n    Object.keys(tokenStorage).forEach(key => {\n      if (tokenStorage[key].pendingRemove) {\n        removedTokens[key] = tokenStorage[key];\n        delete tokenStorage[key];\n      }\n    });\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    Object.keys(removedTokens).forEach(key => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, removedTokens[key]);\n    });\n  }\n  updateRefreshToken(token) {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n  }\n  removeRefreshToken() {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n    this.remove(key);\n  }\n  addPendingRemoveFlags() {\n    const tokens = this.getTokensSync();\n    Object.keys(tokens).forEach(key => {\n      tokens[key].pendingRemove = true;\n    });\n    this.setTokens(tokens);\n  }\n}\nexport { TokenManager };","map":{"version":3,"names":["removeNils","clone","AuthSdkError","isLocalhost","isIE11OrLess","REFRESH_TOKEN_STORAGE_KEY","TOKEN_STORAGE_NAME","validateToken","SdkClock","isRefreshToken","isAccessToken","isIDToken","EVENT_EXPIRED","EVENT_RENEWED","EVENT_ADDED","EVENT_REMOVED","EVENT_ERROR","EVENT_SET_STORAGE","DEFAULT_OPTIONS","autoRenew","autoRemove","syncStorage","clearPendingRemoveTokens","storage","undefined","expireEarlySeconds","storageKey","defaultState","expireTimeouts","renewPromise","TokenManager","constructor","sdk","options","emitter","Object","assign","storageOptions","secure","storageProvider","storageType","storageManager","getTokenStorage","useSeparateCookies","clock","create","state","on","event","handler","context","off","hasSharedStorage","isSharedStorage","start","setExpireEventTimeoutAll","stop","clearExpireEventTimeoutAll","getOptions","getExpireTime","token","expireTime","expiresAt","hasExpired","now","emitExpired","key","emit","emitRenewed","freshToken","oldToken","emitAdded","emitRemoved","emitError","error","clearExpireEventTimeout","clearTimeout","prototype","hasOwnProperty","call","setExpireEventTimeout","expireEventWait","Math","max","expireEventTimeout","setTimeout","tokenStorage","getStorage","resetExpireEventTimeoutAll","add","setStorage","emitSetStorageEvent","getSync","get","_this","_asyncToGenerator","getTokensSync","tokens","keys","forEach","accessToken","idToken","refreshToken","getTokens","_this2","getStorageKeyByType","type","filter","getTokenType","setTokens","accessTokenCb","idTokenCb","refreshTokenCb","handleTokenCallback","handleAdded","handleRenewed","handleRemoved","types","existingTokens","reduce","newToken","existingToken","remove","removedToken","renewToken","_this3","_a","renew","e","Promise","reject","renewTokens","then","tokenType","catch","err","tokenKey","finally","clear","clearStorage","removedTokens","pendingRemove","updateRefreshToken","removeRefreshToken","addPendingRemoveFlags"],"sources":["/Users/tushar/Desktop/fullstack-angular-and-springboot-master/source-code/ecommerce-project-release-3.0/09-security-order-history-secure-backend-and-frontend/03-frontend/angular-ecommerce/node_modules/@okta/okta-auth-js/esm/browser/TokenManager.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { removeNils, clone } from './util/object.js';\nimport AuthSdkError from './errors/AuthSdkError.js';\nimport { isLocalhost, isIE11OrLess } from './features.js';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from './constants.js';\nimport { validateToken } from './oidc/util/validateToken.js';\nimport SdkClock from './clock.js';\nimport './idx/types/api.js';\nimport { isRefreshToken, isAccessToken, isIDToken } from './types/Token.js';\nimport { EVENT_EXPIRED, EVENT_RENEWED, EVENT_ADDED, EVENT_REMOVED, EVENT_ERROR, EVENT_SET_STORAGE } from './types/TokenManager.js';\nimport './myaccount/types.js';\n\nconst DEFAULT_OPTIONS = {\n    autoRenew: true,\n    autoRemove: true,\n    syncStorage: true,\n    clearPendingRemoveTokens: true,\n    storage: undefined,\n    expireEarlySeconds: 30,\n    storageKey: TOKEN_STORAGE_NAME\n};\nfunction defaultState() {\n    return {\n        expireTimeouts: {},\n        renewPromise: null\n    };\n}\nclass TokenManager {\n    constructor(sdk, options = {}) {\n        this.sdk = sdk;\n        this.emitter = sdk.emitter;\n        if (!this.emitter) {\n            throw new AuthSdkError('Emitter should be initialized before TokenManager');\n        }\n        options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n        if (!isLocalhost()) {\n            options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n        }\n        this.options = options;\n        const storageOptions = removeNils({\n            storageKey: options.storageKey,\n            secure: options.secure,\n        });\n        if (typeof options.storage === 'object') {\n            storageOptions.storageProvider = options.storage;\n        }\n        else if (options.storage) {\n            storageOptions.storageType = options.storage;\n        }\n        this.storage = sdk.storageManager.getTokenStorage(Object.assign(Object.assign({}, storageOptions), { useSeparateCookies: true }));\n        this.clock = SdkClock.create( );\n        this.state = defaultState();\n    }\n    on(event, handler, context) {\n        if (context) {\n            this.emitter.on(event, handler, context);\n        }\n        else {\n            this.emitter.on(event, handler);\n        }\n    }\n    off(event, handler) {\n        if (handler) {\n            this.emitter.off(event, handler);\n        }\n        else {\n            this.emitter.off(event);\n        }\n    }\n    hasSharedStorage() {\n        return this.storage.isSharedStorage();\n    }\n    start() {\n        if (this.options.clearPendingRemoveTokens) {\n            this.clearPendingRemoveTokens();\n        }\n        this.setExpireEventTimeoutAll();\n    }\n    stop() {\n        this.clearExpireEventTimeoutAll();\n    }\n    getOptions() {\n        return clone(this.options);\n    }\n    getExpireTime(token) {\n        const expireEarlySeconds = this.options.expireEarlySeconds || 0;\n        var expireTime = token.expiresAt - expireEarlySeconds;\n        return expireTime;\n    }\n    hasExpired(token) {\n        var expireTime = this.getExpireTime(token);\n        return expireTime <= this.clock.now();\n    }\n    emitExpired(key, token) {\n        this.emitter.emit(EVENT_EXPIRED, key, token);\n    }\n    emitRenewed(key, freshToken, oldToken) {\n        this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n    }\n    emitAdded(key, token) {\n        this.emitter.emit(EVENT_ADDED, key, token);\n    }\n    emitRemoved(key, token) {\n        this.emitter.emit(EVENT_REMOVED, key, token);\n    }\n    emitError(error) {\n        this.emitter.emit(EVENT_ERROR, error);\n    }\n    clearExpireEventTimeout(key) {\n        clearTimeout(this.state.expireTimeouts[key]);\n        delete this.state.expireTimeouts[key];\n        this.state.renewPromise = null;\n    }\n    clearExpireEventTimeoutAll() {\n        var expireTimeouts = this.state.expireTimeouts;\n        for (var key in expireTimeouts) {\n            if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n                continue;\n            }\n            this.clearExpireEventTimeout(key);\n        }\n    }\n    setExpireEventTimeout(key, token) {\n        if (isRefreshToken(token)) {\n            return;\n        }\n        var expireTime = this.getExpireTime(token);\n        var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n        this.clearExpireEventTimeout(key);\n        var expireEventTimeout = setTimeout(() => {\n            this.emitExpired(key, token);\n        }, expireEventWait);\n        this.state.expireTimeouts[key] = expireEventTimeout;\n    }\n    setExpireEventTimeoutAll() {\n        var tokenStorage = this.storage.getStorage();\n        for (var key in tokenStorage) {\n            if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n                continue;\n            }\n            var token = tokenStorage[key];\n            this.setExpireEventTimeout(key, token);\n        }\n    }\n    resetExpireEventTimeoutAll() {\n        this.clearExpireEventTimeoutAll();\n        this.setExpireEventTimeoutAll();\n    }\n    add(key, token) {\n        var tokenStorage = this.storage.getStorage();\n        validateToken(token);\n        tokenStorage[key] = token;\n        this.storage.setStorage(tokenStorage);\n        this.emitSetStorageEvent();\n        this.emitAdded(key, token);\n        this.setExpireEventTimeout(key, token);\n    }\n    getSync(key) {\n        var tokenStorage = this.storage.getStorage();\n        return tokenStorage[key];\n    }\n    async get(key) {\n        return this.getSync(key);\n    }\n    getTokensSync() {\n        const tokens = {};\n        const tokenStorage = this.storage.getStorage();\n        Object.keys(tokenStorage).forEach(key => {\n            const token = tokenStorage[key];\n            if (isAccessToken(token)) {\n                tokens.accessToken = token;\n            }\n            else if (isIDToken(token)) {\n                tokens.idToken = token;\n            }\n            else if (isRefreshToken(token)) {\n                tokens.refreshToken = token;\n            }\n        });\n        return tokens;\n    }\n    async getTokens() {\n        return this.getTokensSync();\n    }\n    getStorageKeyByType(type) {\n        const tokenStorage = this.storage.getStorage();\n        const key = Object.keys(tokenStorage).filter(key => {\n            const token = tokenStorage[key];\n            return (isAccessToken(token) && type === 'accessToken')\n                || (isIDToken(token) && type === 'idToken')\n                || (isRefreshToken(token) && type === 'refreshToken');\n        })[0];\n        return key;\n    }\n    getTokenType(token) {\n        if (isAccessToken(token)) {\n            return 'accessToken';\n        }\n        if (isIDToken(token)) {\n            return 'idToken';\n        }\n        if (isRefreshToken(token)) {\n            return 'refreshToken';\n        }\n        throw new AuthSdkError('Unknown token type');\n    }\n    emitSetStorageEvent() {\n        if (isIE11OrLess()) {\n            const storage = this.storage.getStorage();\n            this.emitter.emit(EVENT_SET_STORAGE, storage);\n        }\n    }\n    getStorage() {\n        return this.storage;\n    }\n    setTokens(tokens,\n    accessTokenCb, idTokenCb, refreshTokenCb) {\n        const handleTokenCallback = (key, token) => {\n            const type = this.getTokenType(token);\n            if (type === 'accessToken') {\n                accessTokenCb && accessTokenCb(key, token);\n            }\n            else if (type === 'idToken') {\n                idTokenCb && idTokenCb(key, token);\n            }\n            else if (type === 'refreshToken') {\n                refreshTokenCb && refreshTokenCb(key, token);\n            }\n        };\n        const handleAdded = (key, token) => {\n            this.emitAdded(key, token);\n            this.setExpireEventTimeout(key, token);\n            handleTokenCallback(key, token);\n        };\n        const handleRenewed = (key, token, oldToken) => {\n            this.emitRenewed(key, token, oldToken);\n            this.clearExpireEventTimeout(key);\n            this.setExpireEventTimeout(key, token);\n            handleTokenCallback(key, token);\n        };\n        const handleRemoved = (key, token) => {\n            this.clearExpireEventTimeout(key);\n            this.emitRemoved(key, token);\n            handleTokenCallback(key, token);\n        };\n        const types = ['idToken', 'accessToken', 'refreshToken'];\n        const existingTokens = this.getTokensSync();\n        types.forEach((type) => {\n            const token = tokens[type];\n            if (token) {\n                validateToken(token, type);\n            }\n        });\n        const storage = types.reduce((storage, type) => {\n            const token = tokens[type];\n            if (token) {\n                const storageKey = this.getStorageKeyByType(type) || type;\n                storage[storageKey] = token;\n            }\n            return storage;\n        }, {});\n        this.storage.setStorage(storage);\n        this.emitSetStorageEvent();\n        types.forEach(type => {\n            const newToken = tokens[type];\n            const existingToken = existingTokens[type];\n            const storageKey = this.getStorageKeyByType(type) || type;\n            if (newToken && existingToken) {\n                handleRemoved(storageKey, existingToken);\n                handleAdded(storageKey, newToken);\n                handleRenewed(storageKey, newToken, existingToken);\n            }\n            else if (newToken) {\n                handleAdded(storageKey, newToken);\n            }\n            else if (existingToken) {\n                handleRemoved(storageKey, existingToken);\n            }\n        });\n    }\n    remove(key) {\n        this.clearExpireEventTimeout(key);\n        var tokenStorage = this.storage.getStorage();\n        var removedToken = tokenStorage[key];\n        delete tokenStorage[key];\n        this.storage.setStorage(tokenStorage);\n        this.emitSetStorageEvent();\n        this.emitRemoved(key, removedToken);\n    }\n    async renewToken(token) {\n        var _a;\n        return (_a = this.sdk.token) === null || _a === void 0 ? void 0 : _a.renew(token);\n    }\n    validateToken(token) {\n        return validateToken(token);\n    }\n    renew(key) {\n        if (this.state.renewPromise) {\n            return this.state.renewPromise;\n        }\n        try {\n            var token = this.getSync(key);\n            if (!token) {\n                throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n            }\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n        this.clearExpireEventTimeout(key);\n        this.state.renewPromise = this.sdk.token.renewTokens()\n            .then(tokens => {\n            this.setTokens(tokens);\n            const tokenType = this.getTokenType(token);\n            return tokens[tokenType];\n        })\n            .catch(err => {\n            this.remove(key);\n            err.tokenKey = key;\n            this.emitError(err);\n            throw err;\n        })\n            .finally(() => {\n            this.state.renewPromise = null;\n        });\n        return this.state.renewPromise;\n    }\n    clear() {\n        const tokens = this.getTokensSync();\n        this.clearExpireEventTimeoutAll();\n        this.storage.clearStorage();\n        this.emitSetStorageEvent();\n        Object.keys(tokens).forEach(key => {\n            this.emitRemoved(key, tokens[key]);\n        });\n    }\n    clearPendingRemoveTokens() {\n        const tokenStorage = this.storage.getStorage();\n        const removedTokens = {};\n        Object.keys(tokenStorage).forEach(key => {\n            if (tokenStorage[key].pendingRemove) {\n                removedTokens[key] = tokenStorage[key];\n                delete tokenStorage[key];\n            }\n        });\n        this.storage.setStorage(tokenStorage);\n        this.emitSetStorageEvent();\n        Object.keys(removedTokens).forEach(key => {\n            this.clearExpireEventTimeout(key);\n            this.emitRemoved(key, removedTokens[key]);\n        });\n    }\n    updateRefreshToken(token) {\n        const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n        var tokenStorage = this.storage.getStorage();\n        validateToken(token);\n        tokenStorage[key] = token;\n        this.storage.setStorage(tokenStorage);\n        this.emitSetStorageEvent();\n    }\n    removeRefreshToken() {\n        const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n        this.remove(key);\n    }\n    addPendingRemoveFlags() {\n        const tokens = this.getTokensSync();\n        Object.keys(tokens).forEach(key => {\n            tokens[key].pendingRemove = true;\n        });\n        this.setTokens(tokens);\n    }\n}\n\nexport { TokenManager };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}