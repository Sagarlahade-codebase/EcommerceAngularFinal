{"ast":null,"code":"import _asyncToGenerator from \"/Users/tushar/Desktop/fullstack-angular-and-springboot-master/source-code/ecommerce-project-release-3.0/09-security-order-history-secure-backend-and-frontend/03-frontend/angular-ecommerce/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport fn from '../../util/CookieUtil.js';\nimport sessionStorageHelper from './sessionStorageHelper.js';\nimport { interactionCodeFlow } from './interactionCodeFlow.js';\nimport { FORMS } from '../ion/RemediationConstants.js';\nimport transformIdxResponse from '../ion/transformIdxResponse.js';\nfunction hasAuthenticationSucceeded(idxResponse) {\n  var _idxResponse$rawIdxSt, _idxResponse$rawIdxSt2;\n\n  // Check whether authentication has succeeded. This is done by checking the server response\n  // and seeing if either the 'success' or 'successWithInteractionCode' objects are present.\n  return (idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$rawIdxSt = idxResponse.rawIdxState) === null || _idxResponse$rawIdxSt === void 0 ? void 0 : _idxResponse$rawIdxSt.success) || (idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$rawIdxSt2 = idxResponse.rawIdxState) === null || _idxResponse$rawIdxSt2 === void 0 ? void 0 : _idxResponse$rawIdxSt2.successWithInteractionCode);\n}\n/**\n  * When \"Remember My Username\" is enabled, we save the identifier in a cookie\n  * so that the next time the user visits the SIW, the identifier field can be \n  * pre-filled with this value.\n  */\n\nfunction updateIdentifierCookie(appState, idxResponse) {\n  const settings = appState.settings;\n  if (settings.get('features.rememberMe')) {\n    var _idxResponse$context;\n\n    // Update the cookie with the identifier\n    const user = idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$context = idxResponse.context) === null || _idxResponse$context === void 0 ? void 0 : _idxResponse$context.user;\n    const {\n      identifier: identifier\n    } = (user === null || user === void 0 ? void 0 : user.value) || {};\n    if (identifier) {\n      fn.setUsernameCookie(identifier);\n    }\n  } else {\n    // We remove the cookie explicitly if this feature is disabled.\n    fn.removeUsernameCookie();\n  }\n}\nfunction updateAppState(_x, _x2) {\n  return _updateAppState.apply(this, arguments);\n}\nfunction _updateAppState() {\n  _updateAppState = _asyncToGenerator(function* (appState, idxResponse) {\n    const settings = appState.settings; // Only update the cookie when the user has successfully authenticated themselves \n    // to avoid incorrect/unnecessary updates.\n\n    if (hasAuthenticationSucceeded(idxResponse) && settings.get('features.rememberMyUsernameOnOIE')) {\n      updateIdentifierCookie(appState, idxResponse);\n    }\n    const lastResponse = appState.get('idx');\n    const useInteractionCodeFlow = settings.get('useInteractionCodeFlow');\n    if (useInteractionCodeFlow) {\n      if (idxResponse.interactionCode) {\n        // Although session.stateHandle isn't used by interation flow,\n        // it's better to clean up at the end of the flow.\n        sessionStorageHelper.removeStateHandle(); // This is the end of the IDX flow, now entering OAuth\n\n        const tokens = yield interactionCodeFlow(settings, idxResponse); // reset terminal view in case the were OAuth errors prior to successful token retrieval\n\n        if (appState.get('currentFormName') === FORMS.TERMINAL) {\n          appState.unset('currentFormName', {\n            silent: true\n          });\n        }\n        return tokens;\n      }\n    } else {\n      // Do not save state handle for the first page loads.\n      // Because there shall be no difference between following behavior\n      // 1. bootstrap widget\n      //    -> save state handle to session storage\n      //    -> refresh page\n      //    -> introspect using sessionStorage.stateHandle\n      // 2. bootstrap widget\n      //    -> do not save state handle to session storage\n      //    -> refresh page\n      //    -> introspect using options.stateHandle\n      if (lastResponse) {\n        var _idxResponse$context2;\n        sessionStorageHelper.setStateHandle(idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$context2 = idxResponse.context) === null || _idxResponse$context2 === void 0 ? void 0 : _idxResponse$context2.stateHandle);\n      } // Login flows that mimic step up (moving forward in login pipeline) via internal api calls,\n      // need to clear stored stateHandles.\n      // This way the flow can maintain the latest state handle. For eg. Device probe calls\n\n      if (appState.get('currentFormName') === FORMS.CANCEL_TRANSACTION) {\n        sessionStorageHelper.removeStateHandle();\n      }\n    } // transform response\n\n    const ionResponse = transformIdxResponse(settings, idxResponse, lastResponse);\n    yield appState.setIonResponse(ionResponse);\n  });\n  return _updateAppState.apply(this, arguments);\n}\nexport { updateAppState };","map":{"version":3,"names":["fn","sessionStorageHelper","interactionCodeFlow","FORMS","transformIdxResponse","hasAuthenticationSucceeded","idxResponse","_idxResponse$rawIdxSt","_idxResponse$rawIdxSt2","rawIdxState","success","successWithInteractionCode","updateIdentifierCookie","appState","settings","get","_idxResponse$context","user","context","identifier","value","setUsernameCookie","removeUsernameCookie","updateAppState","_x","_x2","_updateAppState","apply","arguments","_asyncToGenerator","lastResponse","useInteractionCodeFlow","interactionCode","removeStateHandle","tokens","TERMINAL","unset","silent","_idxResponse$context2","setStateHandle","stateHandle","CANCEL_TRANSACTION","ionResponse","setIonResponse"],"sources":["/Users/tushar/Desktop/fullstack-angular-and-springboot-master/source-code/ecommerce-project-release-3.0/09-security-order-history-secure-backend-and-frontend/03-frontend/angular-ecommerce/node_modules/@okta/okta-signin-widget/dist/esm/src/v2/client/updateAppState.js"],"sourcesContent":["import fn from '../../util/CookieUtil.js';\nimport sessionStorageHelper from './sessionStorageHelper.js';\nimport { interactionCodeFlow } from './interactionCodeFlow.js';\nimport { FORMS } from '../ion/RemediationConstants.js';\nimport transformIdxResponse from '../ion/transformIdxResponse.js';\n\nfunction hasAuthenticationSucceeded(idxResponse) {\n  var _idxResponse$rawIdxSt, _idxResponse$rawIdxSt2;\n\n  // Check whether authentication has succeeded. This is done by checking the server response\n  // and seeing if either the 'success' or 'successWithInteractionCode' objects are present.\n  return (idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$rawIdxSt = idxResponse.rawIdxState) === null || _idxResponse$rawIdxSt === void 0 ? void 0 : _idxResponse$rawIdxSt.success) || (idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$rawIdxSt2 = idxResponse.rawIdxState) === null || _idxResponse$rawIdxSt2 === void 0 ? void 0 : _idxResponse$rawIdxSt2.successWithInteractionCode);\n}\n/**\n  * When \"Remember My Username\" is enabled, we save the identifier in a cookie\n  * so that the next time the user visits the SIW, the identifier field can be \n  * pre-filled with this value.\n  */\n\n\nfunction updateIdentifierCookie(appState, idxResponse) {\n  const settings = appState.settings;\n\n  if (settings.get('features.rememberMe')) {\n    var _idxResponse$context;\n\n    // Update the cookie with the identifier\n    const user = idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$context = idxResponse.context) === null || _idxResponse$context === void 0 ? void 0 : _idxResponse$context.user;\n    const {\n      identifier: identifier\n    } = (user === null || user === void 0 ? void 0 : user.value) || {};\n\n    if (identifier) {\n      fn.setUsernameCookie(identifier);\n    }\n  } else {\n    // We remove the cookie explicitly if this feature is disabled.\n    fn.removeUsernameCookie();\n  }\n}\n\nasync function updateAppState(appState, idxResponse) {\n  const settings = appState.settings; // Only update the cookie when the user has successfully authenticated themselves \n  // to avoid incorrect/unnecessary updates.\n\n  if (hasAuthenticationSucceeded(idxResponse) && settings.get('features.rememberMyUsernameOnOIE')) {\n    updateIdentifierCookie(appState, idxResponse);\n  }\n\n  const lastResponse = appState.get('idx');\n  const useInteractionCodeFlow = settings.get('useInteractionCodeFlow');\n\n  if (useInteractionCodeFlow) {\n    if (idxResponse.interactionCode) {\n      // Although session.stateHandle isn't used by interation flow,\n      // it's better to clean up at the end of the flow.\n      sessionStorageHelper.removeStateHandle(); // This is the end of the IDX flow, now entering OAuth\n\n      const tokens = await interactionCodeFlow(settings, idxResponse); // reset terminal view in case the were OAuth errors prior to successful token retrieval\n\n      if (appState.get('currentFormName') === FORMS.TERMINAL) {\n        appState.unset('currentFormName', {\n          silent: true\n        });\n      }\n\n      return tokens;\n    }\n  } else {\n    // Do not save state handle for the first page loads.\n    // Because there shall be no difference between following behavior\n    // 1. bootstrap widget\n    //    -> save state handle to session storage\n    //    -> refresh page\n    //    -> introspect using sessionStorage.stateHandle\n    // 2. bootstrap widget\n    //    -> do not save state handle to session storage\n    //    -> refresh page\n    //    -> introspect using options.stateHandle\n    if (lastResponse) {\n      var _idxResponse$context2;\n\n      sessionStorageHelper.setStateHandle(idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$context2 = idxResponse.context) === null || _idxResponse$context2 === void 0 ? void 0 : _idxResponse$context2.stateHandle);\n    } // Login flows that mimic step up (moving forward in login pipeline) via internal api calls,\n    // need to clear stored stateHandles.\n    // This way the flow can maintain the latest state handle. For eg. Device probe calls\n\n\n    if (appState.get('currentFormName') === FORMS.CANCEL_TRANSACTION) {\n      sessionStorageHelper.removeStateHandle();\n    }\n  } // transform response\n\n\n  const ionResponse = transformIdxResponse(settings, idxResponse, lastResponse);\n  await appState.setIonResponse(ionResponse);\n}\n\nexport { updateAppState };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}