{"ast":null,"code":"import oktaUnderscore from '../../../util/underscore-wrapper.js';\nimport StringUtil from '../../../util/StringUtil.js';\nconst FIELD_REGEX = /^([\\S]+): (.+)$/;\nvar ErrorParser = {\n  /**\n   * Helper function that returns the json output of an xhr objext\n   * @param  {jqXhr} xhr\n   * @return {Object}\n   */\n  getResponseJSON: function (xhr) {\n    try {\n      return xhr.responseJSON || JSON.parse(xhr.responseText);\n    } catch (e) {// ignore error\n    }\n  },\n  /**\n   * Parses an error summary to extract a field name and an error message\n   * @param  {String} errorSummary The raw error summary\n   * @return {String[]} An array with two members: [field name, error message]\n   */\n  parseErrorSummary: function (errorSummary) {\n    const matches = errorSummary.match(FIELD_REGEX); // error format is: `fieldName: The field cannot be left blank`\n\n    if (matches) {\n      return [matches[1], matches[2]];\n    }\n  },\n  /**\n   * Parses an error cause object to extract a field name from property attribute\n   * and an error message form errorSummary attribute. It looks to see if there is\n   * a custom override/translation for the erorrCause.reason before using the errorSummary\n   * @param  {Object} errorCause object\n   * @return {String[]} An array with two members: [field name, error message]\n   */\n  parseErrorCauseObject: function (errorCause) {\n    if (errorCause.property && errorCause.errorSummary) {\n      const localizedMsg = StringUtil.localize(errorCause.reason);\n      const apiMsg = errorCause.errorSummary;\n      const field = errorCause.property;\n      const errorMessage = localizedMsg.indexOf('L10N_ERROR[') === -1 ? localizedMsg : apiMsg;\n      return [field, errorMessage];\n    }\n  },\n  parseErrors: function (resp) {\n    const responseJSON = this.getResponseJSON(resp);\n    return oktaUnderscore.map(responseJSON && responseJSON.errorCauses || [], function (errorCause) {\n      return ('' + errorCause.errorSummary).replace(FIELD_REGEX, '$2');\n    });\n  },\n  /**\n   * Parses the response for errors\n   * Returns a map of field names > array or error messages\n   * Example:\n   * ```javascript\n   * {\n   *   url: ['The field cannot be left blank', 'The field has to be a valid URI'],\n   *   name: ['The field cannot be left blank']\n   * }\n   * ```\n   * @param  {Object} resp\n   * @return {Object}\n   */\n  parseFieldErrors: function (resp) {\n    const responseJSON = this.getResponseJSON(resp);\n    const errors = {}; // xhr error object\n\n    if (responseJSON) {\n      /* eslint complexity: [2, 9] */\n      oktaUnderscore.each(responseJSON.errorCauses || [], function (cause) {\n        let res = [];\n        if (cause.property && cause.errorSummary) {\n          res = this.parseErrorCauseObject(cause);\n        } else if (cause.location && cause.errorSummary) {\n          // To handle new api error format for field level errors.\n          // Ignoring the reason attribute as the translation happens in the API layer and not in the client any more.\n          res = [cause.location, cause.errorSummary];\n        } else {\n          res = this.parseErrorSummary(cause && cause.errorSummary || '');\n        }\n        if (res) {\n          const fieldName = res[0];\n          const message = res[1];\n          errors[fieldName] || (errors[fieldName] = []);\n          errors[fieldName].push(message);\n        }\n      }, this);\n    } // validation key/value object\n    else if (oktaUnderscore.isObject(resp) && oktaUnderscore.size(resp)) {\n      oktaUnderscore.each(resp, function (msg, field) {\n        errors[field] = [msg];\n      });\n    }\n    return oktaUnderscore.size(errors) ? errors : undefined;\n  }\n};\nexport { ErrorParser as default };","map":{"version":3,"names":["oktaUnderscore","StringUtil","FIELD_REGEX","ErrorParser","getResponseJSON","xhr","responseJSON","JSON","parse","responseText","e","parseErrorSummary","errorSummary","matches","match","parseErrorCauseObject","errorCause","property","localizedMsg","localize","reason","apiMsg","field","errorMessage","indexOf","parseErrors","resp","map","errorCauses","replace","parseFieldErrors","errors","each","cause","res","location","fieldName","message","push","isObject","size","msg","undefined","default"],"sources":["/Users/tushar/Desktop/fullstack-angular-and-springboot-master/source-code/ecommerce-project-release-3.0/09-security-order-history-secure-backend-and-frontend/03-frontend/angular-ecommerce/node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/helpers/ErrorParser.js"],"sourcesContent":["import oktaUnderscore from '../../../util/underscore-wrapper.js';\nimport StringUtil from '../../../util/StringUtil.js';\n\nconst FIELD_REGEX = /^([\\S]+): (.+)$/;\nvar ErrorParser = {\n  /**\n   * Helper function that returns the json output of an xhr objext\n   * @param  {jqXhr} xhr\n   * @return {Object}\n   */\n  getResponseJSON: function (xhr) {\n    try {\n      return xhr.responseJSON || JSON.parse(xhr.responseText);\n    } catch (e) {// ignore error\n    }\n  },\n\n  /**\n   * Parses an error summary to extract a field name and an error message\n   * @param  {String} errorSummary The raw error summary\n   * @return {String[]} An array with two members: [field name, error message]\n   */\n  parseErrorSummary: function (errorSummary) {\n    const matches = errorSummary.match(FIELD_REGEX); // error format is: `fieldName: The field cannot be left blank`\n\n    if (matches) {\n      return [matches[1], matches[2]];\n    }\n  },\n\n  /**\n   * Parses an error cause object to extract a field name from property attribute\n   * and an error message form errorSummary attribute. It looks to see if there is\n   * a custom override/translation for the erorrCause.reason before using the errorSummary\n   * @param  {Object} errorCause object\n   * @return {String[]} An array with two members: [field name, error message]\n   */\n  parseErrorCauseObject: function (errorCause) {\n    if (errorCause.property && errorCause.errorSummary) {\n      const localizedMsg = StringUtil.localize(errorCause.reason);\n      const apiMsg = errorCause.errorSummary;\n      const field = errorCause.property;\n      const errorMessage = localizedMsg.indexOf('L10N_ERROR[') === -1 ? localizedMsg : apiMsg;\n      return [field, errorMessage];\n    }\n  },\n  parseErrors: function (resp) {\n    const responseJSON = this.getResponseJSON(resp);\n    return oktaUnderscore.map(responseJSON && responseJSON.errorCauses || [], function (errorCause) {\n      return ('' + errorCause.errorSummary).replace(FIELD_REGEX, '$2');\n    });\n  },\n\n  /**\n   * Parses the response for errors\n   * Returns a map of field names > array or error messages\n   * Example:\n   * ```javascript\n   * {\n   *   url: ['The field cannot be left blank', 'The field has to be a valid URI'],\n   *   name: ['The field cannot be left blank']\n   * }\n   * ```\n   * @param  {Object} resp\n   * @return {Object}\n   */\n  parseFieldErrors: function (resp) {\n    const responseJSON = this.getResponseJSON(resp);\n    const errors = {}; // xhr error object\n\n    if (responseJSON) {\n      /* eslint complexity: [2, 9] */\n      oktaUnderscore.each(responseJSON.errorCauses || [], function (cause) {\n        let res = [];\n\n        if (cause.property && cause.errorSummary) {\n          res = this.parseErrorCauseObject(cause);\n        } else if (cause.location && cause.errorSummary) {\n          // To handle new api error format for field level errors.\n          // Ignoring the reason attribute as the translation happens in the API layer and not in the client any more.\n          res = [cause.location, cause.errorSummary];\n        } else {\n          res = this.parseErrorSummary(cause && cause.errorSummary || '');\n        }\n\n        if (res) {\n          const fieldName = res[0];\n          const message = res[1];\n          errors[fieldName] || (errors[fieldName] = []);\n          errors[fieldName].push(message);\n        }\n      }, this);\n    } // validation key/value object\n    else if (oktaUnderscore.isObject(resp) && oktaUnderscore.size(resp)) {\n      oktaUnderscore.each(resp, function (msg, field) {\n        errors[field] = [msg];\n      });\n    }\n\n    return oktaUnderscore.size(errors) ? errors : undefined;\n  }\n};\n\nexport { ErrorParser as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}