{"ast":null,"code":"import _asyncToGenerator from \"/Users/tushar/Desktop/fullstack-angular-and-springboot-master/source-code/ecommerce-project-release-3.0/09-security-order-history-secure-backend-and-frontend/03-frontend/angular-ecommerce/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ConfiguredFlowError, ConfigError } from '../../util/Errors.js';\nimport { emailVerifyCallback } from './emailVerifyCallback.js';\nimport sessionStorageHelper from './sessionStorageHelper.js';\nimport { CONFIGURED_FLOW } from './constants.js';\n\n/*!\n * Copyright (c) 2021, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nconst handleProxyIdxResponse = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (settings) {\n    return Promise.resolve({\n      rawIdxState: settings.get('proxyIdxResponse'),\n      context: settings.get('proxyIdxResponse'),\n      neededToProceed: []\n    });\n  });\n  return function handleProxyIdxResponse(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/* eslint max-depth: [2, 3] */\n// eslint-disable-next-line complexity, max-statements\nfunction startLoginFlow(_x2) {\n  return _startLoginFlow.apply(this, arguments);\n}\nfunction _startLoginFlow() {\n  _startLoginFlow = _asyncToGenerator(function* (settings) {\n    const authClient = settings.getAuthClient(); // nonce is not a top-level auth-js option, must be passed in manually\n\n    const {\n      authParams: authParams\n    } = settings.toJSON({\n      verbose: true\n    });\n    const nonce = settings.get('nonce') || (authParams === null || authParams === void 0 ? void 0 : authParams.nonce);\n    const idxOptions = {\n      exchangeCodeForTokens: false,\n      // we handle this in interactionCodeFlow.js\n      shouldProceedWithEmailAuthenticator: false,\n      // do not auto-select email authenticator\n      ...(nonce && {\n        nonce: nonce\n      })\n    }; // Return a preset response\n\n    if (settings.get('proxyIdxResponse')) {\n      return handleProxyIdxResponse(settings);\n    }\n    if (settings.get('overrideExistingStateToken')) {\n      sessionStorageHelper.removeStateHandle();\n    }\n    if (settings.get('otp')) {\n      return emailVerifyCallback(settings);\n    }\n    if (settings.get('useInteractionCodeFlow')) {\n      const meta = yield authClient.idx.getSavedTransactionMeta();\n      if (!meta) {\n        // no saved transaction\n        // if the configured flow is set to `proceed`, the SIW should only continue an existing idx transaction\n        // if the SIW loads from a fresh state (there is no current transaction), throw an error\n        const flow = authClient.idx.getFlow();\n        if (flow && flow === CONFIGURED_FLOW.PROCEED) {\n          throw new ConfiguredFlowError('Unable to proceed: saved transaction could not be loaded', flow);\n        } // start new transaction\n\n        return authClient.idx.start(idxOptions); // calls interact\n      } // continue saved transaction\n\n      return authClient.idx.proceed(idxOptions); // calls introspect\n    } // Use stateToken from session storage if exists\n    // See more details at ./docs/use-session-token-prior-to-settings.png\n\n    const stateHandleFromSession = sessionStorageHelper.getStateHandle();\n    if (stateHandleFromSession) {\n      try {\n        var _idxResp$context, _idxResp$context$mess;\n        const idxResp = yield authClient.idx.start({\n          ...idxOptions,\n          stateHandle: stateHandleFromSession\n        });\n        const hasError = ((_idxResp$context = idxResp.context) === null || _idxResp$context === void 0 ? void 0 : (_idxResp$context$mess = _idxResp$context.messages) === null || _idxResp$context$mess === void 0 ? void 0 : _idxResp$context$mess.value.length) > 0;\n        if (hasError) {\n          throw new Error('saved stateToken is invalid'); // will be caught in this function\n        } // 1. abandon the settings.stateHandle given session.stateHandle is still valid\n\n        settings.set('stateToken', stateHandleFromSession); // 2. chain the idxResp to next handler\n\n        return idxResp;\n      } catch {\n        // 1. remove session.stateHandle\n        sessionStorageHelper.removeStateHandle(); // 2. start the login again in order to introspect on settings.stateHandle\n\n        return startLoginFlow(settings);\n      }\n    } // Use stateToken from options\n\n    const stateHandle = settings.get('stateToken');\n    if (stateHandle) {\n      return authClient.idx.start({\n        ...idxOptions,\n        stateHandle: stateHandle\n      });\n    }\n    throw new ConfigError('Set \"useInteractionCodeFlow\" to true in configuration to enable the ' + 'interaction_code\" flow for self-hosted widget.');\n  });\n  return _startLoginFlow.apply(this, arguments);\n}\nexport { startLoginFlow };","map":{"version":3,"names":["ConfiguredFlowError","ConfigError","emailVerifyCallback","sessionStorageHelper","CONFIGURED_FLOW","handleProxyIdxResponse","_ref","_asyncToGenerator","settings","Promise","resolve","rawIdxState","get","context","neededToProceed","_x","apply","arguments","startLoginFlow","_x2","_startLoginFlow","authClient","getAuthClient","authParams","toJSON","verbose","nonce","idxOptions","exchangeCodeForTokens","shouldProceedWithEmailAuthenticator","removeStateHandle","meta","idx","getSavedTransactionMeta","flow","getFlow","PROCEED","start","proceed","stateHandleFromSession","getStateHandle","_idxResp$context","_idxResp$context$mess","idxResp","stateHandle","hasError","messages","value","length","Error","set"],"sources":["/Users/tushar/Desktop/fullstack-angular-and-springboot-master/source-code/ecommerce-project-release-3.0/09-security-order-history-secure-backend-and-frontend/03-frontend/angular-ecommerce/node_modules/@okta/okta-signin-widget/dist/esm/src/v2/client/startLoginFlow.js"],"sourcesContent":["import { ConfiguredFlowError, ConfigError } from '../../util/Errors.js';\nimport { emailVerifyCallback } from './emailVerifyCallback.js';\nimport sessionStorageHelper from './sessionStorageHelper.js';\nimport { CONFIGURED_FLOW } from './constants.js';\n\n/*!\n * Copyright (c) 2021, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nconst handleProxyIdxResponse = async settings => {\n  return Promise.resolve({\n    rawIdxState: settings.get('proxyIdxResponse'),\n    context: settings.get('proxyIdxResponse'),\n    neededToProceed: []\n  });\n};\n/* eslint max-depth: [2, 3] */\n// eslint-disable-next-line complexity, max-statements\n\n\nasync function startLoginFlow(settings) {\n  const authClient = settings.getAuthClient(); // nonce is not a top-level auth-js option, must be passed in manually\n\n  const {\n    authParams: authParams\n  } = settings.toJSON({\n    verbose: true\n  });\n  const nonce = settings.get('nonce') || (authParams === null || authParams === void 0 ? void 0 : authParams.nonce);\n  const idxOptions = {\n    exchangeCodeForTokens: false,\n    // we handle this in interactionCodeFlow.js\n    shouldProceedWithEmailAuthenticator: false,\n    // do not auto-select email authenticator\n    ...(nonce && {\n      nonce: nonce\n    })\n  }; // Return a preset response\n\n  if (settings.get('proxyIdxResponse')) {\n    return handleProxyIdxResponse(settings);\n  }\n\n  if (settings.get('overrideExistingStateToken')) {\n    sessionStorageHelper.removeStateHandle();\n  }\n\n  if (settings.get('otp')) {\n    return emailVerifyCallback(settings);\n  }\n\n  if (settings.get('useInteractionCodeFlow')) {\n    const meta = await authClient.idx.getSavedTransactionMeta();\n\n    if (!meta) {\n      // no saved transaction\n      // if the configured flow is set to `proceed`, the SIW should only continue an existing idx transaction\n      // if the SIW loads from a fresh state (there is no current transaction), throw an error\n      const flow = authClient.idx.getFlow();\n\n      if (flow && flow === CONFIGURED_FLOW.PROCEED) {\n        throw new ConfiguredFlowError('Unable to proceed: saved transaction could not be loaded', flow);\n      } // start new transaction\n\n\n      return authClient.idx.start(idxOptions); // calls interact\n    } // continue saved transaction\n\n\n    return authClient.idx.proceed(idxOptions); // calls introspect\n  } // Use stateToken from session storage if exists\n  // See more details at ./docs/use-session-token-prior-to-settings.png\n\n\n  const stateHandleFromSession = sessionStorageHelper.getStateHandle();\n\n  if (stateHandleFromSession) {\n    try {\n      var _idxResp$context, _idxResp$context$mess;\n\n      const idxResp = await authClient.idx.start({ ...idxOptions,\n        stateHandle: stateHandleFromSession\n      });\n      const hasError = ((_idxResp$context = idxResp.context) === null || _idxResp$context === void 0 ? void 0 : (_idxResp$context$mess = _idxResp$context.messages) === null || _idxResp$context$mess === void 0 ? void 0 : _idxResp$context$mess.value.length) > 0;\n\n      if (hasError) {\n        throw new Error('saved stateToken is invalid'); // will be caught in this function\n      } // 1. abandon the settings.stateHandle given session.stateHandle is still valid\n\n\n      settings.set('stateToken', stateHandleFromSession); // 2. chain the idxResp to next handler\n\n      return idxResp;\n    } catch {\n      // 1. remove session.stateHandle\n      sessionStorageHelper.removeStateHandle(); // 2. start the login again in order to introspect on settings.stateHandle\n\n      return startLoginFlow(settings);\n    }\n  } // Use stateToken from options\n\n\n  const stateHandle = settings.get('stateToken');\n\n  if (stateHandle) {\n    return authClient.idx.start({ ...idxOptions,\n      stateHandle: stateHandle\n    });\n  }\n\n  throw new ConfigError('Set \"useInteractionCodeFlow\" to true in configuration to enable the ' + 'interaction_code\" flow for self-hosted widget.');\n}\n\nexport { startLoginFlow };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}