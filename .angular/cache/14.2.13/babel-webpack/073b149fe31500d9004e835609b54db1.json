{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { __rest } from '../../../_virtual/_tslib.js';\nimport { generateRemediationFunctions } from './remediationParser.js';\nimport generateIdxAction from './generateIdxAction.js';\nimport { JSONPath } from 'jsonpath-plus';\nconst SKIP_FIELDS = Object.fromEntries(['remediation', 'context'].map(field => [field, !!'skip this field']));\nconst parseNonRemediations = function parseNonRemediations(authClient, idxResponse, toPersist = {}) {\n  const actions = {};\n  const context = {};\n  Object.keys(idxResponse).filter(field => !SKIP_FIELDS[field]).forEach(field => {\n    const fieldIsObject = typeof idxResponse[field] === 'object' && !!idxResponse[field];\n    if (!fieldIsObject) {\n      context[field] = idxResponse[field];\n      return;\n    }\n    if (idxResponse[field].rel) {\n      actions[idxResponse[field].name] = generateIdxAction(authClient, idxResponse[field], toPersist);\n      return;\n    }\n    const _a = idxResponse[field],\n      {\n        value: fieldValue,\n        type\n      } = _a,\n      info = __rest(_a, [\"value\", \"type\"]);\n    context[field] = Object.assign({\n      type\n    }, info);\n    if (type !== 'object') {\n      context[field].value = fieldValue;\n      return;\n    }\n    context[field].value = {};\n    Object.entries(fieldValue).forEach(([subField, value]) => {\n      if (value.rel) {\n        actions[`${field}-${subField.name || subField}`] = generateIdxAction(authClient, value, toPersist);\n      } else {\n        context[field].value[subField] = value;\n      }\n    });\n  });\n  return {\n    context,\n    actions\n  };\n};\nconst expandRelatesTo = (idxResponse, value) => {\n  Object.keys(value).forEach(k => {\n    if (k === 'relatesTo') {\n      const query = Array.isArray(value[k]) ? value[k][0] : value[k];\n      if (typeof query === 'string') {\n        const result = JSONPath({\n          path: query,\n          json: idxResponse\n        })[0];\n        if (result) {\n          value[k] = result;\n          return;\n        }\n      }\n    }\n    if (Array.isArray(value[k])) {\n      value[k].forEach(innerValue => expandRelatesTo(idxResponse, innerValue));\n    }\n  });\n};\nconst convertRemediationAction = (authClient, remediation, toPersist) => {\n  if (remediation.rel) {\n    const remediationActions = generateRemediationFunctions(authClient, [remediation], toPersist);\n    const actionFn = remediationActions[remediation.name];\n    return Object.assign(Object.assign({}, remediation), {\n      action: actionFn\n    });\n  }\n  return remediation;\n};\nconst parseIdxResponse = function parseIdxResponse(authClient, idxResponse, toPersist = {}) {\n  var _a;\n  const remediationData = ((_a = idxResponse.remediation) === null || _a === void 0 ? void 0 : _a.value) || [];\n  remediationData.forEach(remediation => expandRelatesTo(idxResponse, remediation));\n  const remediations = remediationData.map(remediation => convertRemediationAction(authClient, remediation, toPersist));\n  const {\n    context,\n    actions\n  } = parseNonRemediations(authClient, idxResponse, toPersist);\n  return {\n    remediations,\n    context,\n    actions\n  };\n};\nexport { parseIdxResponse, parseNonRemediations };","map":{"version":3,"names":["__rest","generateRemediationFunctions","generateIdxAction","JSONPath","SKIP_FIELDS","Object","fromEntries","map","field","parseNonRemediations","authClient","idxResponse","toPersist","actions","context","keys","filter","forEach","fieldIsObject","rel","name","_a","value","fieldValue","type","info","assign","entries","subField","expandRelatesTo","k","query","Array","isArray","result","path","json","innerValue","convertRemediationAction","remediation","remediationActions","actionFn","action","parseIdxResponse","remediationData","remediations"],"sources":["/Users/tushar/Desktop/fullstack-angular-and-springboot-master/source-code/ecommerce-project-release-3.0/09-security-order-history-secure-backend-and-frontend/03-frontend/angular-ecommerce/node_modules/@okta/okta-auth-js/esm/browser/idx/idxState/v1/idxResponseParser.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { __rest } from '../../../_virtual/_tslib.js';\nimport { generateRemediationFunctions } from './remediationParser.js';\nimport generateIdxAction from './generateIdxAction.js';\nimport { JSONPath } from 'jsonpath-plus';\n\nconst SKIP_FIELDS = Object.fromEntries([\n    'remediation',\n    'context',\n].map((field) => [field, !!'skip this field']));\nconst parseNonRemediations = function parseNonRemediations(authClient, idxResponse, toPersist = {}) {\n    const actions = {};\n    const context = {};\n    Object.keys(idxResponse)\n        .filter(field => !SKIP_FIELDS[field])\n        .forEach(field => {\n        const fieldIsObject = typeof idxResponse[field] === 'object' && !!idxResponse[field];\n        if (!fieldIsObject) {\n            context[field] = idxResponse[field];\n            return;\n        }\n        if (idxResponse[field].rel) {\n            actions[idxResponse[field].name] = generateIdxAction(authClient, idxResponse[field], toPersist);\n            return;\n        }\n        const _a = idxResponse[field], { value: fieldValue, type } = _a, info = __rest(_a, [\"value\", \"type\"]);\n        context[field] = Object.assign({ type }, info);\n        if (type !== 'object') {\n            context[field].value = fieldValue;\n            return;\n        }\n        context[field].value = {};\n        Object.entries(fieldValue)\n            .forEach(([subField, value]) => {\n            if (value.rel) {\n                actions[`${field}-${subField.name || subField}`] = generateIdxAction(authClient, value, toPersist);\n            }\n            else {\n                context[field].value[subField] = value;\n            }\n        });\n    });\n    return { context, actions };\n};\nconst expandRelatesTo = (idxResponse, value) => {\n    Object.keys(value).forEach(k => {\n        if (k === 'relatesTo') {\n            const query = Array.isArray(value[k]) ? value[k][0] : value[k];\n            if (typeof query === 'string') {\n                const result = JSONPath({ path: query, json: idxResponse })[0];\n                if (result) {\n                    value[k] = result;\n                    return;\n                }\n            }\n        }\n        if (Array.isArray(value[k])) {\n            value[k].forEach(innerValue => expandRelatesTo(idxResponse, innerValue));\n        }\n    });\n};\nconst convertRemediationAction = (authClient, remediation, toPersist) => {\n    if (remediation.rel) {\n        const remediationActions = generateRemediationFunctions(authClient, [remediation], toPersist);\n        const actionFn = remediationActions[remediation.name];\n        return Object.assign(Object.assign({}, remediation), { action: actionFn });\n    }\n    return remediation;\n};\nconst parseIdxResponse = function parseIdxResponse(authClient, idxResponse, toPersist = {}) {\n    var _a;\n    const remediationData = ((_a = idxResponse.remediation) === null || _a === void 0 ? void 0 : _a.value) || [];\n    remediationData.forEach(remediation => expandRelatesTo(idxResponse, remediation));\n    const remediations = remediationData.map(remediation => convertRemediationAction(authClient, remediation, toPersist));\n    const { context, actions } = parseNonRemediations(authClient, idxResponse, toPersist);\n    return {\n        remediations,\n        context,\n        actions,\n    };\n};\n\nexport { parseIdxResponse, parseNonRemediations };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}