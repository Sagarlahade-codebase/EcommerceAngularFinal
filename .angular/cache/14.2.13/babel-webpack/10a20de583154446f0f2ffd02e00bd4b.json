{"ast":null,"code":"//Copyright 2014-2015 Google Inc. All rights reserved.\n\n//Use of this source code is governed by a BSD-style\n//license that can be found in the LICENSE file or at\n//https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n'use strict';\n\n(function () {\n  var isChrome = 'chrome' in window && window.navigator.userAgent.indexOf('Edge') < 0;\n  if ('u2f' in window || !isChrome) {\n    return;\n  }\n\n  /** Namespace for the U2F api.\n   * @type {Object}\n   */\n  var u2f = window.u2f = {};\n\n  /**\n   * FIDO U2F Javascript API Version\n   * @number\n   */\n  var js_api_version;\n\n  /**\n   * The U2F extension id\n   * @const {string}\n   */\n  // The Chrome packaged app extension ID.\n  // Uncomment this if you want to deploy a server instance that uses\n  // the package Chrome app and does not require installing the U2F Chrome extension.\n  u2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n  // The U2F Chrome extension ID.\n  // Uncomment this if you want to deploy a server instance that uses\n  // the U2F Chrome extension to authenticate.\n  // u2f.EXTENSION_ID = 'pfboblefjcgdjicmnffhdgionmgcdmne';\n\n  /**\n   * Message types for messsages to/from the extension\n   * @const\n   * @enum {string}\n   */\n  u2f.MessageTypes = {\n    'U2F_REGISTER_REQUEST': 'u2f_register_request',\n    'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n    'U2F_SIGN_REQUEST': 'u2f_sign_request',\n    'U2F_SIGN_RESPONSE': 'u2f_sign_response',\n    'U2F_GET_API_VERSION_REQUEST': 'u2f_get_api_version_request',\n    'U2F_GET_API_VERSION_RESPONSE': 'u2f_get_api_version_response'\n  };\n\n  /**\n   * Response status codes\n   * @const\n   * @enum {number}\n   */\n  u2f.ErrorCodes = {\n    'OK': 0,\n    'OTHER_ERROR': 1,\n    'BAD_REQUEST': 2,\n    'CONFIGURATION_UNSUPPORTED': 3,\n    'DEVICE_INELIGIBLE': 4,\n    'TIMEOUT': 5\n  };\n\n  /**\n   * A message for registration requests\n   * @typedef {{\n   *   type: u2f.MessageTypes,\n   *   appId: ?string,\n   *   timeoutSeconds: ?number,\n   *   requestId: ?number\n   * }}\n   */\n  u2f.U2fRequest;\n\n  /**\n   * A message for registration responses\n   * @typedef {{\n   *   type: u2f.MessageTypes,\n   *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n   *   requestId: ?number\n   * }}\n   */\n  u2f.U2fResponse;\n\n  /**\n   * An error object for responses\n   * @typedef {{\n   *   errorCode: u2f.ErrorCodes,\n   *   errorMessage: ?string\n   * }}\n   */\n  u2f.Error;\n\n  /**\n   * Data object for a single sign request.\n   * @typedef {enum {BLUETOOTH_RADIO, BLUETOOTH_LOW_ENERGY, USB, NFC}}\n   */\n  u2f.Transport;\n\n  /**\n   * Data object for a single sign request.\n   * @typedef {Array<u2f.Transport>}\n   */\n  u2f.Transports;\n\n  /**\n   * Data object for a single sign request.\n   * @typedef {{\n   *   version: string,\n   *   challenge: string,\n   *   keyHandle: string,\n   *   appId: string\n   * }}\n   */\n  u2f.SignRequest;\n\n  /**\n   * Data object for a sign response.\n   * @typedef {{\n   *   keyHandle: string,\n   *   signatureData: string,\n   *   clientData: string\n   * }}\n   */\n  u2f.SignResponse;\n\n  /**\n   * Data object for a registration request.\n   * @typedef {{\n   *   version: string,\n   *   challenge: string\n   * }}\n   */\n  u2f.RegisterRequest;\n\n  /**\n   * Data object for a registration response.\n   * @typedef {{\n   *   version: string,\n   *   keyHandle: string,\n   *   transports: Transports,\n   *   appId: string\n   * }}\n   */\n  u2f.RegisterResponse;\n\n  /**\n   * Data object for a registered key.\n   * @typedef {{\n   *   version: string,\n   *   keyHandle: string,\n   *   transports: ?Transports,\n   *   appId: ?string\n   * }}\n   */\n  u2f.RegisteredKey;\n\n  /**\n   * Data object for a get API register response.\n   * @typedef {{\n   *   js_api_version: number\n   * }}\n   */\n  u2f.GetJsApiVersionResponse;\n\n  //Low level MessagePort API support\n\n  /**\n   * Sets up a MessagePort to the U2F extension using the\n   * available mechanisms.\n   * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n   */\n  u2f.getMessagePort = function (callback) {\n    if (typeof chrome != 'undefined' && chrome.runtime) {\n      // The actual message here does not matter, but we need to get a reply\n      // for the callback to run. Thus, send an empty signature request\n      // in order to get a failure response.\n      var msg = {\n        type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n        signRequests: []\n      };\n      chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function () {\n        if (!chrome.runtime.lastError) {\n          // We are on a whitelisted origin and can talk directly\n          // with the extension.\n          u2f.getChromeRuntimePort_(callback);\n        } else {\n          // chrome.runtime was available, but we couldn't message\n          // the extension directly, use iframe\n          u2f.getIframePort_(callback);\n        }\n      });\n    } else if (u2f.isAndroidChrome_()) {\n      u2f.getAuthenticatorPort_(callback);\n    } else if (u2f.isIosChrome_()) {\n      u2f.getIosPort_(callback);\n    } else {\n      // chrome.runtime was not available at all, which is normal\n      // when this origin doesn't have access to any extensions.\n      u2f.getIframePort_(callback);\n    }\n  };\n\n  /**\n   * Detect chrome running on android based on the browser's useragent.\n   * @private\n   */\n  u2f.isAndroidChrome_ = function () {\n    var userAgent = navigator.userAgent;\n    return userAgent.indexOf('Chrome') != -1 && userAgent.indexOf('Android') != -1;\n  };\n\n  /**\n   * Detect chrome running on iOS based on the browser's platform.\n   * @private\n   */\n  u2f.isIosChrome_ = function () {\n    return [\"iPhone\", \"iPad\", \"iPod\"].indexOf(navigator.platform) > -1;\n  };\n\n  /**\n   * Connects directly to the extension via chrome.runtime.connect.\n   * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n   * @private\n   */\n  u2f.getChromeRuntimePort_ = function (callback) {\n    var port = chrome.runtime.connect(u2f.EXTENSION_ID, {\n      'includeTlsChannelId': true\n    });\n    setTimeout(function () {\n      callback(new u2f.WrappedChromeRuntimePort_(port));\n    }, 0);\n  };\n\n  /**\n   * Return a 'port' abstraction to the Authenticator app.\n   * @param {function(u2f.WrappedAuthenticatorPort_)} callback\n   * @private\n   */\n  u2f.getAuthenticatorPort_ = function (callback) {\n    setTimeout(function () {\n      callback(new u2f.WrappedAuthenticatorPort_());\n    }, 0);\n  };\n\n  /**\n   * Return a 'port' abstraction to the iOS client app.\n   * @param {function(u2f.WrappedIosPort_)} callback\n   * @private\n   */\n  u2f.getIosPort_ = function (callback) {\n    setTimeout(function () {\n      callback(new u2f.WrappedIosPort_());\n    }, 0);\n  };\n\n  /**\n   * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n   * @param {Port} port\n   * @constructor\n   * @private\n   */\n  u2f.WrappedChromeRuntimePort_ = function (port) {\n    this.port_ = port;\n  };\n\n  /**\n   * Format and return a sign request compliant with the JS API version supported by the extension.\n   * @param {Array<u2f.SignRequest>} signRequests\n   * @param {number} timeoutSeconds\n   * @param {number} reqId\n   * @return {Object}\n   */\n  u2f.formatSignRequest_ = function (appId, challenge, registeredKeys, timeoutSeconds, reqId) {\n    if (js_api_version === undefined || js_api_version < 1.1) {\n      // Adapt request to the 1.0 JS API\n      var signRequests = [];\n      for (var i = 0; i < registeredKeys.length; i++) {\n        signRequests[i] = {\n          version: registeredKeys[i].version,\n          challenge: challenge,\n          keyHandle: registeredKeys[i].keyHandle,\n          appId: appId\n        };\n      }\n      return {\n        type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n        signRequests: signRequests,\n        timeoutSeconds: timeoutSeconds,\n        requestId: reqId\n      };\n    }\n    // JS 1.1 API\n    return {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      appId: appId,\n      challenge: challenge,\n      registeredKeys: registeredKeys,\n      timeoutSeconds: timeoutSeconds,\n      requestId: reqId\n    };\n  };\n\n  /**\n   * Format and return a register request compliant with the JS API version supported by the extension..\n   * @param {Array<u2f.SignRequest>} signRequests\n   * @param {Array<u2f.RegisterRequest>} signRequests\n   * @param {number} timeoutSeconds\n   * @param {number} reqId\n   * @return {Object}\n   */\n  u2f.formatRegisterRequest_ = function (appId, registeredKeys, registerRequests, timeoutSeconds, reqId) {\n    if (js_api_version === undefined || js_api_version < 1.1) {\n      // Adapt request to the 1.0 JS API\n      for (var i = 0; i < registerRequests.length; i++) {\n        registerRequests[i].appId = appId;\n      }\n      var signRequests = [];\n      for (var i = 0; i < registeredKeys.length; i++) {\n        signRequests[i] = {\n          version: registeredKeys[i].version,\n          challenge: registerRequests[0],\n          keyHandle: registeredKeys[i].keyHandle,\n          appId: appId\n        };\n      }\n      return {\n        type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n        signRequests: signRequests,\n        registerRequests: registerRequests,\n        timeoutSeconds: timeoutSeconds,\n        requestId: reqId\n      };\n    }\n    // JS 1.1 API\n    return {\n      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n      appId: appId,\n      registerRequests: registerRequests,\n      registeredKeys: registeredKeys,\n      timeoutSeconds: timeoutSeconds,\n      requestId: reqId\n    };\n  };\n\n  /**\n   * Posts a message on the underlying channel.\n   * @param {Object} message\n   */\n  u2f.WrappedChromeRuntimePort_.prototype.postMessage = function (message) {\n    this.port_.postMessage(message);\n  };\n\n  /**\n   * Emulates the HTML 5 addEventListener interface. Works only for the\n   * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n   * @param {string} eventName\n   * @param {function({data: Object})} handler\n   */\n  u2f.WrappedChromeRuntimePort_.prototype.addEventListener = function (eventName, handler) {\n    var name = eventName.toLowerCase();\n    if (name == 'message' || name == 'onmessage') {\n      this.port_.onMessage.addListener(function (message) {\n        // Emulate a minimal MessageEvent object\n        handler({\n          'data': message\n        });\n      });\n    } else {\n      console.error('WrappedChromeRuntimePort only supports onMessage');\n    }\n  };\n\n  /**\n   * Wrap the Authenticator app with a MessagePort interface.\n   * @constructor\n   * @private\n   */\n  u2f.WrappedAuthenticatorPort_ = function () {\n    this.requestId_ = -1;\n    this.requestObject_ = null;\n  };\n\n  /**\n   * Launch the Authenticator intent.\n   * @param {Object} message\n   */\n  u2f.WrappedAuthenticatorPort_.prototype.postMessage = function (message) {\n    var intentUrl = u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ + ';S.request=' + encodeURIComponent(JSON.stringify(message)) + ';end';\n    document.location = intentUrl;\n  };\n\n  /**\n   * Tells what type of port this is.\n   * @return {String} port type\n   */\n  u2f.WrappedAuthenticatorPort_.prototype.getPortType = function () {\n    return \"WrappedAuthenticatorPort_\";\n  };\n\n  /**\n   * Emulates the HTML 5 addEventListener interface.\n   * @param {string} eventName\n   * @param {function({data: Object})} handler\n   */\n  u2f.WrappedAuthenticatorPort_.prototype.addEventListener = function (eventName, handler) {\n    var name = eventName.toLowerCase();\n    if (name == 'message') {\n      var self = this;\n      /* Register a callback to that executes when\n       * chrome injects the response. */\n      window.addEventListener('message', self.onRequestUpdate_.bind(self, handler), false);\n    } else {\n      console.error('WrappedAuthenticatorPort only supports message');\n    }\n  };\n\n  /**\n   * Callback invoked  when a response is received from the Authenticator.\n   * @param function({data: Object}) callback\n   * @param {Object} message message Object\n   */\n  u2f.WrappedAuthenticatorPort_.prototype.onRequestUpdate_ = function (callback, message) {\n    var messageObject = JSON.parse(message.data);\n    var intentUrl = messageObject['intentURL'];\n    var errorCode = messageObject['errorCode'];\n    var responseObject = null;\n    if (messageObject.hasOwnProperty('data')) {\n      responseObject = /** @type {Object} */\n      JSON.parse(messageObject['data']);\n    }\n    callback({\n      'data': responseObject\n    });\n  };\n\n  /**\n   * Base URL for intents to Authenticator.\n   * @const\n   * @private\n   */\n  u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ = 'intent:#Intent;action=com.google.android.apps.authenticator.AUTHENTICATE';\n\n  /**\n   * Wrap the iOS client app with a MessagePort interface.\n   * @constructor\n   * @private\n   */\n  u2f.WrappedIosPort_ = function () {};\n\n  /**\n   * Launch the iOS client app request\n   * @param {Object} message\n   */\n  u2f.WrappedIosPort_.prototype.postMessage = function (message) {\n    var str = JSON.stringify(message);\n    var url = \"u2f://auth?\" + encodeURI(str);\n    location.replace(url);\n  };\n\n  /**\n   * Tells what type of port this is.\n   * @return {String} port type\n   */\n  u2f.WrappedIosPort_.prototype.getPortType = function () {\n    return \"WrappedIosPort_\";\n  };\n\n  /**\n   * Emulates the HTML 5 addEventListener interface.\n   * @param {string} eventName\n   * @param {function({data: Object})} handler\n   */\n  u2f.WrappedIosPort_.prototype.addEventListener = function (eventName, handler) {\n    var name = eventName.toLowerCase();\n    if (name !== 'message') {\n      console.error('WrappedIosPort only supports message');\n    }\n  };\n\n  /**\n   * Sets up an embedded trampoline iframe, sourced from the extension.\n   * @param {function(MessagePort)} callback\n   * @private\n   */\n  u2f.getIframePort_ = function (callback) {\n    // Create the iframe\n    var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n    var iframe = document.createElement('iframe');\n    iframe.src = iframeOrigin + '/u2f-comms.html';\n    iframe.setAttribute('style', 'display:none');\n    document.body.appendChild(iframe);\n    var channel = new MessageChannel();\n    var ready = function (message) {\n      if (message.data == 'ready') {\n        channel.port1.removeEventListener('message', ready);\n        callback(channel.port1);\n      } else {\n        console.error('First event on iframe port was not \"ready\"');\n      }\n    };\n    channel.port1.addEventListener('message', ready);\n    channel.port1.start();\n    iframe.addEventListener('load', function () {\n      // Deliver the port to the iframe and initialize\n      iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n    });\n  };\n\n  //High-level JS API\n\n  /**\n   * Default extension response timeout in seconds.\n   * @const\n   */\n  u2f.EXTENSION_TIMEOUT_SEC = 30;\n\n  /**\n   * A singleton instance for a MessagePort to the extension.\n   * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n   * @private\n   */\n  u2f.port_ = null;\n\n  /**\n   * Callbacks waiting for a port\n   * @type {Array<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n   * @private\n   */\n  u2f.waitingForPort_ = [];\n\n  /**\n   * A counter for requestIds.\n   * @type {number}\n   * @private\n   */\n  u2f.reqCounter_ = 0;\n\n  /**\n   * A map from requestIds to client callbacks\n   * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n   *                       |function((u2f.Error|u2f.SignResponse)))>}\n   * @private\n   */\n  u2f.callbackMap_ = {};\n\n  /**\n   * Creates or retrieves the MessagePort singleton to use.\n   * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n   * @private\n   */\n  u2f.getPortSingleton_ = function (callback) {\n    if (u2f.port_) {\n      callback(u2f.port_);\n    } else {\n      if (u2f.waitingForPort_.length == 0) {\n        u2f.getMessagePort(function (port) {\n          u2f.port_ = port;\n          u2f.port_.addEventListener('message', /** @type {function(Event)} */u2f.responseHandler_);\n\n          // Careful, here be async callbacks. Maybe.\n          while (u2f.waitingForPort_.length) u2f.waitingForPort_.shift()(u2f.port_);\n        });\n      }\n      u2f.waitingForPort_.push(callback);\n    }\n  };\n\n  /**\n   * Handles response messages from the extension.\n   * @param {MessageEvent.<u2f.Response>} message\n   * @private\n   */\n  u2f.responseHandler_ = function (message) {\n    var response = message.data;\n    var reqId = response['requestId'];\n    if (!reqId || !u2f.callbackMap_[reqId]) {\n      console.error('Unknown or missing requestId in response.');\n      return;\n    }\n    var cb = u2f.callbackMap_[reqId];\n    delete u2f.callbackMap_[reqId];\n    cb(response['responseData']);\n  };\n\n  /**\n   * Dispatches an array of sign requests to available U2F tokens.\n   * If the JS API version supported by the extension is unknown, it first sends a\n   * message to the extension to find out the supported API version and then it sends\n   * the sign request.\n   * @param {string=} appId\n   * @param {string=} challenge\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.SignResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.sign = function (appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n    if (js_api_version === undefined) {\n      // Send a message to get the extension to JS API version, then send the actual sign request.\n      u2f.getApiVersion(function (response) {\n        js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];\n        console.log(\"Extension JS API Version: \", js_api_version);\n        u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n      });\n    } else {\n      // We know the JS API version. Send the actual sign request in the supported API version.\n      u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n    }\n  };\n\n  /**\n   * Dispatches an array of sign requests to available U2F tokens.\n   * @param {string=} appId\n   * @param {string=} challenge\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.SignResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.sendSignRequest = function (appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function (port) {\n      var reqId = ++u2f.reqCounter_;\n      u2f.callbackMap_[reqId] = callback;\n      var timeoutSeconds = typeof opt_timeoutSeconds !== 'undefined' ? opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC;\n      var req = u2f.formatSignRequest_(appId, challenge, registeredKeys, timeoutSeconds, reqId);\n      port.postMessage(req);\n    });\n  };\n\n  /**\n   * Dispatches register requests to available U2F tokens. An array of sign\n   * requests identifies already registered tokens.\n   * If the JS API version supported by the extension is unknown, it first sends a\n   * message to the extension to find out the supported API version and then it sends\n   * the register request.\n   * @param {string=} appId\n   * @param {Array<u2f.RegisterRequest>} registerRequests\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.register = function (appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n    if (js_api_version === undefined) {\n      // Send a message to get the extension to JS API version, then send the actual register request.\n      u2f.getApiVersion(function (response) {\n        js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];\n        console.log(\"Extension JS API Version: \", js_api_version);\n        u2f.sendRegisterRequest(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds);\n      });\n    } else {\n      // We know the JS API version. Send the actual register request in the supported API version.\n      u2f.sendRegisterRequest(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds);\n    }\n  };\n\n  /**\n   * Dispatches register requests to available U2F tokens. An array of sign\n   * requests identifies already registered tokens.\n   * @param {string=} appId\n   * @param {Array<u2f.RegisterRequest>} registerRequests\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.sendRegisterRequest = function (appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function (port) {\n      var reqId = ++u2f.reqCounter_;\n      u2f.callbackMap_[reqId] = callback;\n      var timeoutSeconds = typeof opt_timeoutSeconds !== 'undefined' ? opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC;\n      var req = u2f.formatRegisterRequest_(appId, registeredKeys, registerRequests, timeoutSeconds, reqId);\n      port.postMessage(req);\n    });\n  };\n\n  /**\n   * Dispatches a message to the extension to find out the supported\n   * JS API version.\n   * If the user is on a mobile phone and is thus using Google Authenticator instead\n   * of the Chrome extension, don't send the request and simply return 0.\n   * @param {function((u2f.Error|u2f.GetJsApiVersionResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.getApiVersion = function (callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function (port) {\n      // If we are using Android Google Authenticator or iOS client app,\n      // do not fire an intent to ask which JS API version to use.\n      if (port.getPortType) {\n        var apiVersion;\n        switch (port.getPortType()) {\n          case 'WrappedIosPort_':\n          case 'WrappedAuthenticatorPort_':\n            apiVersion = 1.1;\n            break;\n          default:\n            apiVersion = 0;\n            break;\n        }\n        callback({\n          'js_api_version': apiVersion\n        });\n        return;\n      }\n      var reqId = ++u2f.reqCounter_;\n      u2f.callbackMap_[reqId] = callback;\n      var req = {\n        type: u2f.MessageTypes.U2F_GET_API_VERSION_REQUEST,\n        timeoutSeconds: typeof opt_timeoutSeconds !== 'undefined' ? opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC,\n        requestId: reqId\n      };\n      port.postMessage(req);\n    });\n  };\n})();","map":{"version":3,"names":["isChrome","window","navigator","userAgent","indexOf","u2f","js_api_version","EXTENSION_ID","MessageTypes","ErrorCodes","U2fRequest","U2fResponse","Error","Transport","Transports","SignRequest","SignResponse","RegisterRequest","RegisterResponse","RegisteredKey","GetJsApiVersionResponse","getMessagePort","callback","chrome","runtime","msg","type","U2F_SIGN_REQUEST","signRequests","sendMessage","lastError","getChromeRuntimePort_","getIframePort_","isAndroidChrome_","getAuthenticatorPort_","isIosChrome_","getIosPort_","platform","port","connect","setTimeout","WrappedChromeRuntimePort_","WrappedAuthenticatorPort_","WrappedIosPort_","port_","formatSignRequest_","appId","challenge","registeredKeys","timeoutSeconds","reqId","undefined","i","length","version","keyHandle","requestId","formatRegisterRequest_","registerRequests","U2F_REGISTER_REQUEST","prototype","postMessage","message","addEventListener","eventName","handler","name","toLowerCase","onMessage","addListener","console","error","requestId_","requestObject_","intentUrl","INTENT_URL_BASE_","encodeURIComponent","JSON","stringify","document","location","getPortType","self","onRequestUpdate_","bind","messageObject","parse","data","errorCode","responseObject","hasOwnProperty","str","url","encodeURI","replace","iframeOrigin","iframe","createElement","src","setAttribute","body","appendChild","channel","MessageChannel","ready","port1","removeEventListener","start","contentWindow","port2","EXTENSION_TIMEOUT_SEC","waitingForPort_","reqCounter_","callbackMap_","getPortSingleton_","responseHandler_","shift","push","response","cb","sign","opt_timeoutSeconds","getApiVersion","log","sendSignRequest","req","register","sendRegisterRequest","apiVersion","U2F_GET_API_VERSION_REQUEST"],"sources":["/Users/tushar/Desktop/fullstack-angular-and-springboot-master/source-code/ecommerce-project-release-3.0/09-security-order-history-secure-backend-and-frontend/03-frontend/angular-ecommerce/node_modules/u2f-api-polyfill/u2f-api-polyfill.js"],"sourcesContent":["\n//Copyright 2014-2015 Google Inc. All rights reserved.\n\n//Use of this source code is governed by a BSD-style\n//license that can be found in the LICENSE file or at\n//https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n'use strict';\n\n(function (){\n  var isChrome = 'chrome' in window && window.navigator.userAgent.indexOf('Edge') < 0;\n  if ('u2f' in window || !isChrome) {\n    return;\n  }\n\n  /** Namespace for the U2F api.\n   * @type {Object}\n   */\n  var u2f = window.u2f = {};\n\n  /**\n   * FIDO U2F Javascript API Version\n   * @number\n   */\n  var js_api_version;\n\n  /**\n   * The U2F extension id\n   * @const {string}\n   */\n  // The Chrome packaged app extension ID.\n  // Uncomment this if you want to deploy a server instance that uses\n  // the package Chrome app and does not require installing the U2F Chrome extension.\n   u2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n  // The U2F Chrome extension ID.\n  // Uncomment this if you want to deploy a server instance that uses\n  // the U2F Chrome extension to authenticate.\n  // u2f.EXTENSION_ID = 'pfboblefjcgdjicmnffhdgionmgcdmne';\n\n\n  /**\n   * Message types for messsages to/from the extension\n   * @const\n   * @enum {string}\n   */\n  u2f.MessageTypes = {\n      'U2F_REGISTER_REQUEST': 'u2f_register_request',\n      'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n      'U2F_SIGN_REQUEST': 'u2f_sign_request',\n      'U2F_SIGN_RESPONSE': 'u2f_sign_response',\n      'U2F_GET_API_VERSION_REQUEST': 'u2f_get_api_version_request',\n      'U2F_GET_API_VERSION_RESPONSE': 'u2f_get_api_version_response'\n  };\n\n\n  /**\n   * Response status codes\n   * @const\n   * @enum {number}\n   */\n  u2f.ErrorCodes = {\n      'OK': 0,\n      'OTHER_ERROR': 1,\n      'BAD_REQUEST': 2,\n      'CONFIGURATION_UNSUPPORTED': 3,\n      'DEVICE_INELIGIBLE': 4,\n      'TIMEOUT': 5\n  };\n\n\n  /**\n   * A message for registration requests\n   * @typedef {{\n   *   type: u2f.MessageTypes,\n   *   appId: ?string,\n   *   timeoutSeconds: ?number,\n   *   requestId: ?number\n   * }}\n   */\n  u2f.U2fRequest;\n\n\n  /**\n   * A message for registration responses\n   * @typedef {{\n   *   type: u2f.MessageTypes,\n   *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n   *   requestId: ?number\n   * }}\n   */\n  u2f.U2fResponse;\n\n\n  /**\n   * An error object for responses\n   * @typedef {{\n   *   errorCode: u2f.ErrorCodes,\n   *   errorMessage: ?string\n   * }}\n   */\n  u2f.Error;\n\n  /**\n   * Data object for a single sign request.\n   * @typedef {enum {BLUETOOTH_RADIO, BLUETOOTH_LOW_ENERGY, USB, NFC}}\n   */\n  u2f.Transport;\n\n\n  /**\n   * Data object for a single sign request.\n   * @typedef {Array<u2f.Transport>}\n   */\n  u2f.Transports;\n\n  /**\n   * Data object for a single sign request.\n   * @typedef {{\n   *   version: string,\n   *   challenge: string,\n   *   keyHandle: string,\n   *   appId: string\n   * }}\n   */\n  u2f.SignRequest;\n\n\n  /**\n   * Data object for a sign response.\n   * @typedef {{\n   *   keyHandle: string,\n   *   signatureData: string,\n   *   clientData: string\n   * }}\n   */\n  u2f.SignResponse;\n\n\n  /**\n   * Data object for a registration request.\n   * @typedef {{\n   *   version: string,\n   *   challenge: string\n   * }}\n   */\n  u2f.RegisterRequest;\n\n\n  /**\n   * Data object for a registration response.\n   * @typedef {{\n   *   version: string,\n   *   keyHandle: string,\n   *   transports: Transports,\n   *   appId: string\n   * }}\n   */\n  u2f.RegisterResponse;\n\n\n  /**\n   * Data object for a registered key.\n   * @typedef {{\n   *   version: string,\n   *   keyHandle: string,\n   *   transports: ?Transports,\n   *   appId: ?string\n   * }}\n   */\n  u2f.RegisteredKey;\n\n\n  /**\n   * Data object for a get API register response.\n   * @typedef {{\n   *   js_api_version: number\n   * }}\n   */\n  u2f.GetJsApiVersionResponse;\n\n\n  //Low level MessagePort API support\n\n  /**\n   * Sets up a MessagePort to the U2F extension using the\n   * available mechanisms.\n   * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n   */\n  u2f.getMessagePort = function(callback) {\n    if (typeof chrome != 'undefined' && chrome.runtime) {\n      // The actual message here does not matter, but we need to get a reply\n      // for the callback to run. Thus, send an empty signature request\n      // in order to get a failure response.\n      var msg = {\n          type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n          signRequests: []\n      };\n      chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {\n        if (!chrome.runtime.lastError) {\n          // We are on a whitelisted origin and can talk directly\n          // with the extension.\n          u2f.getChromeRuntimePort_(callback);\n        } else {\n          // chrome.runtime was available, but we couldn't message\n          // the extension directly, use iframe\n          u2f.getIframePort_(callback);\n        }\n      });\n    } else if (u2f.isAndroidChrome_()) {\n      u2f.getAuthenticatorPort_(callback);\n    } else if (u2f.isIosChrome_()) {\n      u2f.getIosPort_(callback);\n    } else {\n      // chrome.runtime was not available at all, which is normal\n      // when this origin doesn't have access to any extensions.\n      u2f.getIframePort_(callback);\n    }\n  };\n\n  /**\n   * Detect chrome running on android based on the browser's useragent.\n   * @private\n   */\n  u2f.isAndroidChrome_ = function() {\n    var userAgent = navigator.userAgent;\n    return userAgent.indexOf('Chrome') != -1 &&\n    userAgent.indexOf('Android') != -1;\n  };\n\n  /**\n   * Detect chrome running on iOS based on the browser's platform.\n   * @private\n   */\n  u2f.isIosChrome_ = function() {\n    return [\"iPhone\", \"iPad\", \"iPod\"].indexOf(navigator.platform) > -1;\n  };\n\n  /**\n   * Connects directly to the extension via chrome.runtime.connect.\n   * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n   * @private\n   */\n  u2f.getChromeRuntimePort_ = function(callback) {\n    var port = chrome.runtime.connect(u2f.EXTENSION_ID,\n        {'includeTlsChannelId': true});\n    setTimeout(function() {\n      callback(new u2f.WrappedChromeRuntimePort_(port));\n    }, 0);\n  };\n\n  /**\n   * Return a 'port' abstraction to the Authenticator app.\n   * @param {function(u2f.WrappedAuthenticatorPort_)} callback\n   * @private\n   */\n  u2f.getAuthenticatorPort_ = function(callback) {\n    setTimeout(function() {\n      callback(new u2f.WrappedAuthenticatorPort_());\n    }, 0);\n  };\n\n  /**\n   * Return a 'port' abstraction to the iOS client app.\n   * @param {function(u2f.WrappedIosPort_)} callback\n   * @private\n   */\n  u2f.getIosPort_ = function(callback) {\n    setTimeout(function() {\n      callback(new u2f.WrappedIosPort_());\n    }, 0);\n  };\n\n  /**\n   * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n   * @param {Port} port\n   * @constructor\n   * @private\n   */\n  u2f.WrappedChromeRuntimePort_ = function(port) {\n    this.port_ = port;\n  };\n\n  /**\n   * Format and return a sign request compliant with the JS API version supported by the extension.\n   * @param {Array<u2f.SignRequest>} signRequests\n   * @param {number} timeoutSeconds\n   * @param {number} reqId\n   * @return {Object}\n   */\n  u2f.formatSignRequest_ =\n    function(appId, challenge, registeredKeys, timeoutSeconds, reqId) {\n    if (js_api_version === undefined || js_api_version < 1.1) {\n      // Adapt request to the 1.0 JS API\n      var signRequests = [];\n      for (var i = 0; i < registeredKeys.length; i++) {\n        signRequests[i] = {\n            version: registeredKeys[i].version,\n            challenge: challenge,\n            keyHandle: registeredKeys[i].keyHandle,\n            appId: appId\n        };\n      }\n      return {\n        type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n        signRequests: signRequests,\n        timeoutSeconds: timeoutSeconds,\n        requestId: reqId\n      };\n    }\n    // JS 1.1 API\n    return {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      appId: appId,\n      challenge: challenge,\n      registeredKeys: registeredKeys,\n      timeoutSeconds: timeoutSeconds,\n      requestId: reqId\n    };\n  };\n\n  /**\n   * Format and return a register request compliant with the JS API version supported by the extension..\n   * @param {Array<u2f.SignRequest>} signRequests\n   * @param {Array<u2f.RegisterRequest>} signRequests\n   * @param {number} timeoutSeconds\n   * @param {number} reqId\n   * @return {Object}\n   */\n  u2f.formatRegisterRequest_ =\n    function(appId, registeredKeys, registerRequests, timeoutSeconds, reqId) {\n    if (js_api_version === undefined || js_api_version < 1.1) {\n      // Adapt request to the 1.0 JS API\n      for (var i = 0; i < registerRequests.length; i++) {\n        registerRequests[i].appId = appId;\n      }\n      var signRequests = [];\n      for (var i = 0; i < registeredKeys.length; i++) {\n        signRequests[i] = {\n            version: registeredKeys[i].version,\n            challenge: registerRequests[0],\n            keyHandle: registeredKeys[i].keyHandle,\n            appId: appId\n        };\n      }\n      return {\n        type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n        signRequests: signRequests,\n        registerRequests: registerRequests,\n        timeoutSeconds: timeoutSeconds,\n        requestId: reqId\n      };\n    }\n    // JS 1.1 API\n    return {\n      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n      appId: appId,\n      registerRequests: registerRequests,\n      registeredKeys: registeredKeys,\n      timeoutSeconds: timeoutSeconds,\n      requestId: reqId\n    };\n  };\n\n\n  /**\n   * Posts a message on the underlying channel.\n   * @param {Object} message\n   */\n  u2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {\n    this.port_.postMessage(message);\n  };\n\n\n  /**\n   * Emulates the HTML 5 addEventListener interface. Works only for the\n   * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n   * @param {string} eventName\n   * @param {function({data: Object})} handler\n   */\n  u2f.WrappedChromeRuntimePort_.prototype.addEventListener =\n      function(eventName, handler) {\n    var name = eventName.toLowerCase();\n    if (name == 'message' || name == 'onmessage') {\n      this.port_.onMessage.addListener(function(message) {\n        // Emulate a minimal MessageEvent object\n        handler({'data': message});\n      });\n    } else {\n      console.error('WrappedChromeRuntimePort only supports onMessage');\n    }\n  };\n\n  /**\n   * Wrap the Authenticator app with a MessagePort interface.\n   * @constructor\n   * @private\n   */\n  u2f.WrappedAuthenticatorPort_ = function() {\n    this.requestId_ = -1;\n    this.requestObject_ = null;\n  }\n\n  /**\n   * Launch the Authenticator intent.\n   * @param {Object} message\n   */\n  u2f.WrappedAuthenticatorPort_.prototype.postMessage = function(message) {\n    var intentUrl =\n      u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ +\n      ';S.request=' + encodeURIComponent(JSON.stringify(message)) +\n      ';end';\n    document.location = intentUrl;\n  };\n\n  /**\n   * Tells what type of port this is.\n   * @return {String} port type\n   */\n  u2f.WrappedAuthenticatorPort_.prototype.getPortType = function() {\n    return \"WrappedAuthenticatorPort_\";\n  };\n\n\n  /**\n   * Emulates the HTML 5 addEventListener interface.\n   * @param {string} eventName\n   * @param {function({data: Object})} handler\n   */\n  u2f.WrappedAuthenticatorPort_.prototype.addEventListener = function(eventName, handler) {\n    var name = eventName.toLowerCase();\n    if (name == 'message') {\n      var self = this;\n      /* Register a callback to that executes when\n       * chrome injects the response. */\n      window.addEventListener(\n          'message', self.onRequestUpdate_.bind(self, handler), false);\n    } else {\n      console.error('WrappedAuthenticatorPort only supports message');\n    }\n  };\n\n  /**\n   * Callback invoked  when a response is received from the Authenticator.\n   * @param function({data: Object}) callback\n   * @param {Object} message message Object\n   */\n  u2f.WrappedAuthenticatorPort_.prototype.onRequestUpdate_ =\n      function(callback, message) {\n    var messageObject = JSON.parse(message.data);\n    var intentUrl = messageObject['intentURL'];\n\n    var errorCode = messageObject['errorCode'];\n    var responseObject = null;\n    if (messageObject.hasOwnProperty('data')) {\n      responseObject = /** @type {Object} */ (\n          JSON.parse(messageObject['data']));\n    }\n\n    callback({'data': responseObject});\n  };\n\n  /**\n   * Base URL for intents to Authenticator.\n   * @const\n   * @private\n   */\n  u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ =\n    'intent:#Intent;action=com.google.android.apps.authenticator.AUTHENTICATE';\n\n  /**\n   * Wrap the iOS client app with a MessagePort interface.\n   * @constructor\n   * @private\n   */\n  u2f.WrappedIosPort_ = function() {};\n\n  /**\n   * Launch the iOS client app request\n   * @param {Object} message\n   */\n  u2f.WrappedIosPort_.prototype.postMessage = function(message) {\n    var str = JSON.stringify(message);\n    var url = \"u2f://auth?\" + encodeURI(str);\n    location.replace(url);\n  };\n\n  /**\n   * Tells what type of port this is.\n   * @return {String} port type\n   */\n  u2f.WrappedIosPort_.prototype.getPortType = function() {\n    return \"WrappedIosPort_\";\n  };\n\n  /**\n   * Emulates the HTML 5 addEventListener interface.\n   * @param {string} eventName\n   * @param {function({data: Object})} handler\n   */\n  u2f.WrappedIosPort_.prototype.addEventListener = function(eventName, handler) {\n    var name = eventName.toLowerCase();\n    if (name !== 'message') {\n      console.error('WrappedIosPort only supports message');\n    }\n  };\n\n  /**\n   * Sets up an embedded trampoline iframe, sourced from the extension.\n   * @param {function(MessagePort)} callback\n   * @private\n   */\n  u2f.getIframePort_ = function(callback) {\n    // Create the iframe\n    var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n    var iframe = document.createElement('iframe');\n    iframe.src = iframeOrigin + '/u2f-comms.html';\n    iframe.setAttribute('style', 'display:none');\n    document.body.appendChild(iframe);\n\n    var channel = new MessageChannel();\n    var ready = function(message) {\n      if (message.data == 'ready') {\n        channel.port1.removeEventListener('message', ready);\n        callback(channel.port1);\n      } else {\n        console.error('First event on iframe port was not \"ready\"');\n      }\n    };\n    channel.port1.addEventListener('message', ready);\n    channel.port1.start();\n\n    iframe.addEventListener('load', function() {\n      // Deliver the port to the iframe and initialize\n      iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n    });\n  };\n\n\n  //High-level JS API\n\n  /**\n   * Default extension response timeout in seconds.\n   * @const\n   */\n  u2f.EXTENSION_TIMEOUT_SEC = 30;\n\n  /**\n   * A singleton instance for a MessagePort to the extension.\n   * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n   * @private\n   */\n  u2f.port_ = null;\n\n  /**\n   * Callbacks waiting for a port\n   * @type {Array<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n   * @private\n   */\n  u2f.waitingForPort_ = [];\n\n  /**\n   * A counter for requestIds.\n   * @type {number}\n   * @private\n   */\n  u2f.reqCounter_ = 0;\n\n  /**\n   * A map from requestIds to client callbacks\n   * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n   *                       |function((u2f.Error|u2f.SignResponse)))>}\n   * @private\n   */\n  u2f.callbackMap_ = {};\n\n  /**\n   * Creates or retrieves the MessagePort singleton to use.\n   * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n   * @private\n   */\n  u2f.getPortSingleton_ = function(callback) {\n    if (u2f.port_) {\n      callback(u2f.port_);\n    } else {\n      if (u2f.waitingForPort_.length == 0) {\n        u2f.getMessagePort(function(port) {\n          u2f.port_ = port;\n          u2f.port_.addEventListener('message',\n              /** @type {function(Event)} */ (u2f.responseHandler_));\n\n          // Careful, here be async callbacks. Maybe.\n          while (u2f.waitingForPort_.length)\n            u2f.waitingForPort_.shift()(u2f.port_);\n        });\n      }\n      u2f.waitingForPort_.push(callback);\n    }\n  };\n\n  /**\n   * Handles response messages from the extension.\n   * @param {MessageEvent.<u2f.Response>} message\n   * @private\n   */\n  u2f.responseHandler_ = function(message) {\n    var response = message.data;\n    var reqId = response['requestId'];\n    if (!reqId || !u2f.callbackMap_[reqId]) {\n      console.error('Unknown or missing requestId in response.');\n      return;\n    }\n    var cb = u2f.callbackMap_[reqId];\n    delete u2f.callbackMap_[reqId];\n    cb(response['responseData']);\n  };\n\n  /**\n   * Dispatches an array of sign requests to available U2F tokens.\n   * If the JS API version supported by the extension is unknown, it first sends a\n   * message to the extension to find out the supported API version and then it sends\n   * the sign request.\n   * @param {string=} appId\n   * @param {string=} challenge\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.SignResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.sign = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n    if (js_api_version === undefined) {\n      // Send a message to get the extension to JS API version, then send the actual sign request.\n      u2f.getApiVersion(\n          function (response) {\n            js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];\n            console.log(\"Extension JS API Version: \", js_api_version);\n            u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n          });\n    } else {\n      // We know the JS API version. Send the actual sign request in the supported API version.\n      u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n    }\n  };\n\n  /**\n   * Dispatches an array of sign requests to available U2F tokens.\n   * @param {string=} appId\n   * @param {string=} challenge\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.SignResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.sendSignRequest = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function(port) {\n      var reqId = ++u2f.reqCounter_;\n      u2f.callbackMap_[reqId] = callback;\n      var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?\n          opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);\n      var req = u2f.formatSignRequest_(appId, challenge, registeredKeys, timeoutSeconds, reqId);\n      port.postMessage(req);\n    });\n  };\n\n  /**\n   * Dispatches register requests to available U2F tokens. An array of sign\n   * requests identifies already registered tokens.\n   * If the JS API version supported by the extension is unknown, it first sends a\n   * message to the extension to find out the supported API version and then it sends\n   * the register request.\n   * @param {string=} appId\n   * @param {Array<u2f.RegisterRequest>} registerRequests\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.register = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n    if (js_api_version === undefined) {\n      // Send a message to get the extension to JS API version, then send the actual register request.\n      u2f.getApiVersion(\n          function (response) {\n            js_api_version = response['js_api_version'] === undefined ? 0: response['js_api_version'];\n            console.log(\"Extension JS API Version: \", js_api_version);\n            u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,\n                callback, opt_timeoutSeconds);\n          });\n    } else {\n      // We know the JS API version. Send the actual register request in the supported API version.\n      u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,\n          callback, opt_timeoutSeconds);\n    }\n  };\n\n  /**\n   * Dispatches register requests to available U2F tokens. An array of sign\n   * requests identifies already registered tokens.\n   * @param {string=} appId\n   * @param {Array<u2f.RegisterRequest>} registerRequests\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.sendRegisterRequest = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function(port) {\n      var reqId = ++u2f.reqCounter_;\n      u2f.callbackMap_[reqId] = callback;\n      var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?\n          opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);\n      var req = u2f.formatRegisterRequest_(\n          appId, registeredKeys, registerRequests, timeoutSeconds, reqId);\n      port.postMessage(req);\n    });\n  };\n\n\n  /**\n   * Dispatches a message to the extension to find out the supported\n   * JS API version.\n   * If the user is on a mobile phone and is thus using Google Authenticator instead\n   * of the Chrome extension, don't send the request and simply return 0.\n   * @param {function((u2f.Error|u2f.GetJsApiVersionResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.getApiVersion = function(callback, opt_timeoutSeconds) {\n   u2f.getPortSingleton_(function(port) {\n     // If we are using Android Google Authenticator or iOS client app,\n     // do not fire an intent to ask which JS API version to use.\n     if (port.getPortType) {\n       var apiVersion;\n       switch (port.getPortType()) {\n         case 'WrappedIosPort_':\n         case 'WrappedAuthenticatorPort_':\n           apiVersion = 1.1;\n           break;\n\n         default:\n           apiVersion = 0;\n           break;\n       }\n       callback({ 'js_api_version': apiVersion });\n       return;\n     }\n      var reqId = ++u2f.reqCounter_;\n      u2f.callbackMap_[reqId] = callback;\n      var req = {\n        type: u2f.MessageTypes.U2F_GET_API_VERSION_REQUEST,\n        timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n            opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n        requestId: reqId\n      };\n      port.postMessage(req);\n    });\n  };\n})();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}